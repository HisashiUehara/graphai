export { AgentFunction, AgentFunctionDictonary, GraphData } from "./type";
import { AgentFunctionDictonary, GraphData, DataSource, ResultDataDictonary, ResultData, DefaultResultData } from "./type";
import { TransactionLog } from "./log";
import { ComputedNode, StaticNode } from "./node";
import { TaskManager } from "./task";
type GraphNodes = Record<string, ComputedNode | StaticNode>;
export declare class GraphAI {
    private data;
    nodes: GraphNodes;
    callbackDictonary: AgentFunctionDictonary;
    onLogCallback: (__log: TransactionLog, __isUpdate: boolean) => void;
    private runningNodes;
    taskManager: TaskManager;
    private onComplete;
    private loop?;
    private repeatCount;
    verbose: boolean;
    private logs;
    private createNodes;
    private getValueFromResults;
    private initializeNodes;
    constructor(data: GraphData, callbackDictonary: AgentFunctionDictonary, taskManager?: TaskManager | undefined);
    getCallback(agentId?: string): import("./type").AgentFunction<any, any, any>;
    asString(): string;
    results<T = DefaultResultData>(): ResultDataDictonary<T>;
    errors(): Record<string, Error>;
    private pushReadyNodesIntoQueue;
    pushQueueIfReady(node: ComputedNode): void;
    pushQueue(node: ComputedNode): void;
    run<T = DefaultResultData>(): Promise<ResultDataDictonary<T>>;
    private runNode;
    onExecutionComplete(node: ComputedNode): void;
    private removeRunning;
    isRunning(): boolean;
    private processLoopIfNecessary;
    appendLog(log: TransactionLog): void;
    updateLog(log: TransactionLog): void;
    transactionLogs(): TransactionLog[];
    injectValue(nodeId: string, value: ResultData): void;
    resultsOf(sources: Array<DataSource>): any[];
}
