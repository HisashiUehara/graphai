"use strict";var e=require("graphai"),a=require("@graphai/agent_utils");const t=async({params:a,namedInputs:t})=>{e.assert(!!t,"stringSplitterAgent: namedInputs is UNDEFINED!");const r=t.text,s=a.chunkSize??2048,n=a.overlap??Math.floor(s/8),o=Math.floor(r.length/(s-n))+1;return{contents:new Array(o).fill(void 0).map(((e,a)=>{const t=a*(s-n);return r.substring(t,t+s)})),count:o,chunkSize:s,overlap:n}},r={name:"stringSplitterAgent",agent:t,mock:t,inputs:{type:"object",properties:{text:{type:"string",description:"text to be chuncked"}},required:["text"]},output:{type:"object",properties:{contents:{type:"array",description:"the array of text chunks"},count:{type:"number",description:"the number of chunks"},chunkSize:{type:"number",description:"the chunk size"},overlap:{type:"number",description:"the overlap size"}}},samples:[{inputs:{text:"Here's to the crazy ones, the misfits, the rebels, the troublemakers, the round pegs in the square holes ... the ones who see things differently -- they're not fond of rules, and they have no respect for the status quo. ... You can quote them, disagree with them, glorify or vilify them, but the only thing you can't do is ignore them because they change things. ... They push the human race forward, and while some may see them as the crazy ones, we see genius, because the people who are crazy enough to think that they can change the world, are the ones who do."},params:{chunkSize:64},result:{contents:["Here's to the crazy ones, the misfits, the rebels, the troublema","roublemakers, the round pegs in the square holes ... the ones wh"," ones who see things differently -- they're not fond of rules, a","rules, and they have no respect for the status quo. ... You can ","You can quote them, disagree with them, glorify or vilify them, ","y them, but the only thing you can't do is ignore them because t","ecause they change things. ... They push the human race forward,","forward, and while some may see them as the crazy ones, we see g","we see genius, because the people who are crazy enough to think ","o think that they can change the world, are the ones who do."," do."],count:11,chunkSize:64,overlap:8}}],description:"This agent strip one long string into chunks using following parameters",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",license:"MIT"},s=(a,t,r)=>"string"==typeof a?a===t?r:a.replace(t,r):Array.isArray(a)?a.map((e=>s(e,t,r))):e.isObject(a)?Object.keys(a).reduce(((e,n)=>(e[n]=s(a[n],t,r),e)),{}):a,n=async({params:e,namedInputs:a})=>{if(void 0===e.template){if(a.text)return a.text;console.warn("warning: stringTemplateAgent no template")}return Object.keys(a).reduce(((e,t)=>s(e,"${"+t+"}",a[t])),e.template)},o={message1:"hello",message2:"test"},p={name:"stringTemplateAgent",agent:n,mock:n,samples:[{inputs:o,params:{template:"${message1}: ${message2}"},result:"hello: test"},{inputs:o,params:{template:["${message1}: ${message2}","${message2}: ${message1}"]},result:["hello: test","test: hello"]},{inputs:o,params:{template:{apple:"${message1}",lemon:"${message2}"}},result:{apple:"hello",lemon:"test"}},{inputs:o,params:{template:[{apple:"${message1}",lemon:"${message2}"}]},result:[{apple:"hello",lemon:"test"}]},{inputs:o,params:{template:{apple:"${message1}",lemon:["${message2}"]}},result:{apple:"hello",lemon:["test"]}},{inputs:{agent:"openAiAgent",row:"hello world",params:{text:"message"}},params:{template:{version:.5,nodes:{ai:{agent:"${agent}",isResult:!0,params:"${params}",inputs:{prompt:"${row}"}}}}},result:{nodes:{ai:{agent:"openAiAgent",inputs:{prompt:"hello world"},isResult:!0,params:{text:"message"}}},version:.5}}],description:"Template agent",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",license:"MIT"},i=async({namedInputs:e})=>{const{text:a,data:t}=e;if(t)return JSON.stringify(t,null,2);const r=("\n"+a).match(/\n```[a-zA-z]*([\s\S]*?)\n```/);return r?JSON.parse(r[1]):JSON.parse(a)},u={apple:"red",lemon:"yellow"},l=JSON.stringify(u),m=["```",l,"```"].join("\n"),c=["```json",l,"```"].join("\n"),y=["```JSON",l,"```"].join("\n"),g={name:"jsonParserAgent",agent:i,mock:i,inputs:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},output:{type:"string"},samples:[{inputs:{data:u},params:{},result:JSON.stringify(u,null,2)},{inputs:{text:JSON.stringify(u,null,2)},params:{},result:u},{inputs:{text:m},params:{},result:u},{inputs:{text:c},params:{},result:u},{inputs:{text:y},params:{},result:u}],description:"Template agent",category:["string"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",license:"MIT"},d=async({namedInputs:e,params:a})=>{const{suffix:t}=a,r=e.text.trim().replace(/[\s-_]+/g," ").toLowerCase().split(" ");t&&r[r.length-1]!==t&&r.push(t);const s=r.join(" ");return{lowerCamelCase:r.map(((e,a)=>0===a?e:e.charAt(0).toUpperCase()+e.slice(1))).join(""),snakeCase:s.replace(/\s+/g,"_"),kebabCase:s.replace(/\s+/g,"-"),normalized:s}},h={name:"stringCaseVariantsAgent",agent:d,mock:d,samples:[{inputs:{text:"this is a pen"},params:{},result:{kebabCase:"this-is-a-pen",lowerCamelCase:"thisIsAPen",normalized:"this is a pen",snakeCase:"this_is_a_pen"}},{inputs:{text:"string case variants"},params:{suffix:"agent"},result:{kebabCase:"string-case-variants-agent",lowerCamelCase:"stringCaseVariantsAgent",normalized:"string case variants agent",snakeCase:"string_case_variants_agent"}}],description:"Format String Cases agent",category:["string"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},b=(a,t)=>async r=>{const{namedInputs:s,log:n,debugInfo:o,params:p,forNestedGraph:i}=r;e.assert(!!i,"Please update graphai to 0.5.19 or higher");const{agents:u,graphOptions:l,onLogCallback:m,callbacks:c}=i,{taskManager:y}=l,g=p.throwError??!1;if(y){const a=y.getStatus(!1);e.assert(a.concurrency>a.running,`nestedAgent: Concurrency is too low: ${a.concurrency}`)}e.assert(!!a,"nestedAgent: graph is required");const{nodes:d}=a,h=Object.keys(d).reduce(((e,a)=>{const t=d[a];if("agent"in t)e[a]=t;else{const{value:r,update:s,isResult:n,console:o}=t;e[a]={value:r,update:s,isResult:n,console:o}}return e}),{}),b={...a,nodes:h,version:e.graphDataLatestVersion},f=Object.keys(s);f.length>0&&f.forEach((e=>{void 0===b.nodes[e]?b.nodes[e]={value:s[e]}:void 0!==s[e]&&(b.nodes[e].value=s[e])}));try{void 0===b.version&&o.version&&(b.version=o.version);const a=new e.GraphAI(b,u||{},l);m&&(a.onLogCallback=m),c&&(a.callbacks=c),o.subGraphs.set(a.graphId,a);const r=await a.run(!1);return o.subGraphs.delete(a.graphId),n?.push(...a.transactionLogs()),t&&t.resultNodeId?r[t.resultNodeId]:r}catch(e){if(e instanceof Error&&!g)return{onError:{message:e.message,error:e}};throw e}},f=async a=>{const{forNestedGraph:t}=a,{graphData:r}=t??{graphData:{nodes:{}}};return e.assert(!!r,"No GraphData"),await b(r)(a)},w={name:"nestedAgent",agent:f,mock:f,samples:[{inputs:{message:"hello"},params:{},result:{test:["hello"]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"messages"},inputs:{messages:[":message"]},isResult:!0}}}}],description:"nested Agent",category:["graph"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},A={version:e.graphDataLatestVersion,nodes:{newText:{value:""},oldText:{value:""},isNewText:{if:":newText",agent:"copyAgent",inputs:{text:":newText"}},isOldText:{unless:":newText",agent:"copyAgent",inputs:{text:":oldText"}},updatedText:{agent:"copyAgent",anyInput:!0,inputs:{text:[":isNewText.text",":isOldText.text"]}},resultText:{isResult:!0,agent:"copyAgent",anyInput:!0,inputs:{text:":updatedText.text.$0"}}}},I=b(A,{resultNodeId:"resultText"}),x={name:"stringUpdateTextAgent",agent:I,mock:I,samples:[{inputs:{newText:"new",oldText:"old"},params:{},result:{text:"new"}},{inputs:{newText:"",oldText:"old"},params:{},result:{text:"old"}},{inputs:{},params:{},result:{text:""}},{inputs:{oldText:"old"},params:{},result:{text:"old"}}],description:"",category:[],author:"",repository:"",tools:[],license:"",hasGraphData:!0},T=async({namedInputs:t})=>{const r=" Set inputs: { array: :arrayNodeId, item: :itemNodeId }";a.arrayValidate("pushAgent",t,r);const{item:s,items:n}=t;e.assert(!(!s&&!n),"pushAgent: namedInputs.item is UNDEFINED!"+r);const o=t.array.map((e=>e));return s?o.push(s):n.forEach((e=>{o.push(e)})),{array:o}},k={name:"pushAgent",agent:T,mock:T,inputs:{type:"object",properties:{array:{type:"array",description:"the array to push an item to"},item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item push into the array"},items:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item push into the array"}},required:["array"]},output:{type:"object",properties:{array:{type:"array"}}},samples:[{inputs:{array:[1,2],item:3},params:{},result:{array:[1,2,3]}},{inputs:{array:[{apple:1}],item:{lemon:2}},params:{},result:{array:[{apple:1},{lemon:2}]}},{inputs:{array:[{apple:1}],items:[{lemon:2},{banana:3}]},params:{},result:{array:[{apple:1},{lemon:2},{banana:3}]}}],description:"push Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},v=async({namedInputs:e})=>{a.arrayValidate("popAgent",e);const t=e.array.map((e=>e)),r=t.pop();return{array:t,item:r}},j={name:"popAgent",agent:v,mock:v,inputs:{type:"object",properties:{array:{type:"array",description:"the array to pop an item from"}},required:["array"]},output:{type:"object",properties:{item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item popped from the array"},array:{type:"array",description:"the remaining array"}}},samples:[{inputs:{array:[1,2,3]},params:{},result:{array:[1,2],item:3}},{inputs:{array:["a","b","c"]},params:{},result:{array:["a","b"],item:"c"}},{inputs:{array:[1,2,3],array2:["a","b","c"]},params:{},result:{array:[1,2],item:3}}],description:"Pop Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},E=async({namedInputs:e})=>{a.arrayValidate("shiftAgent",e);const t=e.array.map((e=>e)),r=t.shift();return{array:t,item:r}},N={name:"shiftAgent",agent:E,mock:E,inputs:{type:"object",properties:{array:{type:"array",description:"the array to shift an item from"}},required:["array"]},output:{type:"object",properties:{item:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}],description:"the item shifted from the array"},array:{type:"array",description:"the remaining array"}}},samples:[{inputs:{array:[1,2,3]},params:{},result:{array:[2,3],item:1}},{inputs:{array:["a","b","c"]},params:{},result:{array:["b","c"],item:"a"}}],description:"shift Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},R=async({namedInputs:e,params:t})=>{a.arrayValidate("arrayFlatAgent",e);const r=t.depth??1;return{array:e.array.map((e=>e)).flat(r)}},M={name:"arrayFlatAgent",agent:R,mock:R,inputs:{type:"object",properties:{array:{type:"array",description:"flat array"}},required:["array"]},output:{type:"object",properties:{array:{type:"array",description:"the remaining array"}}},params:{type:"object",properties:{depth:{type:"number",description:"array depth"}}},samples:[{inputs:{array:[[1],[2],[3]]},params:{},result:{array:[1,2,3]}},{inputs:{array:[[1],[2],[[3]]]},params:{},result:{array:[1,2,[3]]}},{inputs:{array:[[1],[2],[[3]]]},params:{depth:2},result:{array:[1,2,3]}},{inputs:{array:[["a"],["b"],["c"]]},params:{},result:{array:["a","b","c"]}}],description:"Array Flat Agent",category:["array"],author:"Receptron team",repository:"https://github.com/receptron/graphai",cacheType:"pureAgent",license:"MIT"},_=async({namedInputs:e,params:t})=>{a.arrayValidate("arrayJoinAgent",e);const r=t.separator??"",{flat:s}=t;return{text:s?e.array.flat(s).join(r):e.array.join(r)}},O={name:"arrayJoinAgent",agent:_,mock:_,inputs:{type:"object",properties:{array:{type:"array",description:"array join"}},required:["array"]},params:{type:"object",properties:{separator:{type:"string",description:"array join separator"},flat:{type:"number",description:"array flat depth"}}},output:{type:"object",properties:{text:{type:"string",description:"joined text"}}},samples:[{inputs:{array:[[1],[2],[3]]},params:{},result:{text:"123"}},{inputs:{array:[[1],[2],[[3]]]},params:{},result:{text:"123"}},{inputs:{array:[["a"],["b"],["c"]]},params:{},result:{text:"abc"}},{inputs:{array:[[1],[2],[3]]},params:{separator:"|"},result:{text:"1|2|3"}},{inputs:{array:[[[1]],[[2],[3]]]},params:{separator:"|"},result:{text:"1|2,3"}},{inputs:{array:[[[1]],[[2],[3]]]},params:{separator:"|",flat:1},result:{text:"1|2|3"}},{inputs:{array:[[[[1]],[[2],[3]]]]},params:{separator:"|",flat:1},result:{text:"1|2,3"}},{inputs:{array:[[[[1]],[[2],[3]]]]},params:{separator:"|",flat:2},result:{text:"1|2|3"}}],description:"Array Join Agent",category:["array"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},S=async({namedInputs:a})=>{e.assert(!!a,"dotProductAgent: namedInputs is UNDEFINED!");const t=a.matrix,r=a.vector;if(t[0].length!=r.length)throw new Error(`dotProduct: Length of vectors do not match. ${t[0].length}, ${r.length}`);return t.map((e=>e.reduce(((e,a,t)=>e+a*r[t]),0)))},V={name:"dotProductAgent",agent:S,mock:S,inputs:{type:"object",properties:{matrix:{type:"array",description:"two dimentional matrix",items:{type:"array",items:{type:"number"}}},vector:{type:"array",description:"the vector",items:{type:"number"}}},required:["matrix","vector"]},output:{type:"array"},samples:[{inputs:{matrix:[[1,2],[3,4],[5,6]],vector:[3,2]},params:{},result:[7,17,27]},{inputs:{matrix:[[1,2],[2,3]],vector:[1,2]},params:{},result:[5,8]}],description:"dotProduct Agent",category:["matrix"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},D=async({params:a,namedInputs:t})=>{e.assert(!!t,"sortByValue: namedInputs is UNDEFINED!"),e.assert(!!t.array,"sortByValue: namedInputs.array is UNDEFINED!"),e.assert(!!t.values,"sortByValue: namedInputs.values is UNDEFINED!");const r=a?.assendant?-1:1,s=t.array,n=t.values;return s.map(((e,a)=>({item:e,value:n[a]}))).sort(((e,a)=>(a.value-e.value)*r)).map((e=>e.item))},P={name:"sortByValuesAgent",agent:D,mock:D,inputs:{type:"object",properties:{array:{type:"array",description:"the array to sort"},values:{type:"array",description:"values associated with items in the array"}},required:["array","values"]},output:{type:"array"},samples:[{inputs:{array:["banana","orange","lemon","apple"],values:[2,5,6,4]},params:{},result:["lemon","orange","apple","banana"]},{inputs:{array:["banana","orange","lemon","apple"],values:[2,5,6,4]},params:{assendant:!0},result:["banana","apple","orange","lemon"]}],description:"sortByValues Agent",category:["matrix"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},$=async({params:e,filterParams:a})=>e.filterParams?a:e,q={name:"echoAgent",agent:$,mock:$,samples:[{inputs:{},params:{text:"this is test"},result:{text:"this is test"}},{inputs:{},params:{text:"If you add filterParams option, it will respond to filterParams",filterParams:!0},result:{}}],description:"Echo agent",category:["test"],cacheType:"pureAgent",author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",license:"MIT"},C=async({params:e})=>({list:new Array(e.count).fill(void 0).map(((e,a)=>a))}),F={name:"countingAgent",agent:C,mock:C,samples:[{inputs:{},params:{count:4},result:{list:[0,1,2,3]}}],description:"Counting agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},U=async({params:e})=>({messages:new Array(e.count).fill(void 0).map((()=>e.message))}),z={name:"copyMessageAgent",agent:U,mock:U,samples:[{inputs:{},params:{count:4,message:"hello"},result:{messages:["hello","hello","hello","hello"]}}],description:"CopyMessage agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},G=async({namedInputs:t,params:r})=>{e.assert(a.isNamedInputs(t),"copy2ArrayAgent: namedInputs is UNDEFINED!");const s=t.item?t.item:t;return new Array(r.count).fill(void 0).map((()=>s))},J={name:"copy2ArrayAgent",agent:G,mock:G,samples:[{inputs:{item:{message:"hello"}},params:{count:10},result:[{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"}]},{inputs:{message:"hello"},params:{count:10},result:[{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"},{message:"hello"}]},{inputs:{item:"hello"},params:{count:10},result:["hello","hello","hello","hello","hello","hello","hello","hello","hello","hello"]}],description:"Copy2Array agent",category:["test"],cacheType:"pureAgent",author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},Y=async({debugInfo:{nodeId:e},namedInputs:t})=>{a.arrayValidate("mergeNodeIdAgent",t);return t.array.reduce(((e,a)=>({...e,...a})),{[e]:"hello"})},L={name:"mergeNodeIdAgent",agent:Y,mock:Y,samples:[{inputs:{array:[{message:"hello"}]},params:{},result:{message:"hello",test:"hello"}}],description:"merge node id agent",category:["test"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},K=async({params:a,filterParams:t,namedInputs:r})=>{const s=a.message??r.message??"";for await(const r of s.split(""))t.streamTokenCallback&&t.streamTokenCallback(r),await e.sleep(a.sleep||100);return{message:s}},H={name:"streamMockAgent",agent:K,mock:K,inputs:{anyOf:[{type:"object",properties:{message:{type:"string",description:"streaming message"}}},{type:"array"}]},samples:[{inputs:{},params:{message:"this is params test"},result:{message:"this is params test"}},{inputs:{message:"this is named inputs test"},params:{},result:{message:"this is named inputs test"}}],description:"Stream mock agent",category:["test"],author:"Isamu Arimoto",repository:"https://github.com/receptron/graphai",license:"MIT",stream:!0},X=async({params:a,namedInputs:t,log:r,debugInfo:s,forNestedGraph:n})=>{e.assert(!!n,"Please update graphai to 0.5.19 or higher");const{limit:o,resultAll:p,compositeResult:i,throwError:u}=a,{agents:l,graphData:m,graphOptions:c,onLogCallback:y,callbacks:g}=n,{taskManager:d}=c;if(d){const a=d.getStatus();e.assert(a.concurrency>a.running,`mapAgent: Concurrency is too low: ${a.concurrency}`)}e.assert(!!t.rows,"mapAgent: rows property is required in namedInput"),e.assert(!!m,"mapAgent: graph is required");const h=t.rows.map((e=>e));o&&o<h.length&&(h.length=o);const{nodes:b}=m,f={...m,nodes:{...b},version:e.graphDataLatestVersion},w=Object.keys(t);f.nodes.__mapIndex={},w.forEach((e=>{const a="rows"===e?"row":e;void 0===f.nodes[a]?f.nodes[a]={value:t[e]}:"agent"in f.nodes[a]||(f.nodes[a].value=t[e])}));try{void 0===f.version&&s.version&&(f.version=s.version);const a=h.map(((a,t)=>{const r=new e.GraphAI(f,l||{},c);return s.subGraphs.set(r.graphId,r),r.injectValue("row",a,"__mapAgent_inputs__"),r.injectValue("__mapIndex",t,"__mapAgent_inputs__"),y&&(r.onLogCallback=y),g&&(r.callbacks=g),r})),t=a.map((e=>e.run(p))),n=await Promise.all(t),o=Object.keys(n[0]);if(a.map((e=>{s.subGraphs.delete(e.graphId)})),r){const e=a.map(((e,a)=>e.transactionLogs().map((e=>(e.mapIndex=a,e)))));r.push(...e.flat())}if(i){return o.reduce(((e,a)=>(e[a]=n.map((e=>e[a])),e)),{})}return n}catch(e){if(e instanceof Error&&!u)return{onError:{message:e.message,error:e}};throw e}},B={name:"mapAgent",agent:X,mock:X,samples:[{inputs:{rows:[1,2]},params:{},result:[{test:[1]},{test:[2]}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]},isResult:!0}}}},{inputs:{rows:["apple","orange","banana","lemon","melon","pineapple","tomato"]},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${word}."},inputs:{word:":row"},isResult:!0}}},result:[{node2:"I love apple."},{node2:"I love orange."},{node2:"I love banana."},{node2:"I love lemon."},{node2:"I love melon."},{node2:"I love pineapple."},{node2:"I love tomato."}]},{inputs:{rows:[{fruit:"apple"},{fruit:"orange"}]},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${item}."},inputs:{item:":row.fruit"},isResult:!0}}},result:[{node2:"I love apple."},{node2:"I love orange."}]},{inputs:{rows:[{fruit:"apple"},{fruit:"orange"}],name:"You",verb:"like"},params:{},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"${name} ${verb} ${fruit}."},inputs:{fruit:":row.fruit",name:":name",verb:":verb"},isResult:!0}}},result:[{node2:"You like apple."},{node2:"You like orange."}]},{inputs:{rows:[1,2]},params:{resultAll:!0},result:[{__mapIndex:0,test:[1],row:1},{__mapIndex:1,test:[2],row:2}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}},{inputs:{rows:[1,2]},params:{resultAll:!0},result:[{__mapIndex:0,map:[{test:1},{test:1}],row:1,test:1},{__mapIndex:1,map:[{test:2},{test:2}],test:2,row:2}],graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"row"},inputs:{row:":row"}},map:{agent:"mapAgent",inputs:{rows:[":test",":test"]},graph:{nodes:{test:{isResult:!0,agent:"copyAgent",params:{namedKey:"row"},inputs:{row:":row"}}}}}}}},{inputs:{rows:[1,2]},params:{compositeResult:!0},result:{test:[[1],[2]]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]},isResult:!0}}}},{inputs:{rows:["apple","orange","banana","lemon","melon","pineapple","tomato"]},params:{compositeResult:!0},graph:{nodes:{node2:{agent:"stringTemplateAgent",params:{template:"I love ${row}."},inputs:{row:":row"},isResult:!0}}},result:{node2:["I love apple.","I love orange.","I love banana.","I love lemon.","I love melon.","I love pineapple.","I love tomato."]}},{inputs:{rows:[1,2]},params:{resultAll:!0,compositeResult:!0},result:{test:[[1],[2]],__mapIndex:[0,1],row:[1,2]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}},{inputs:{rows:[1,2]},params:{resultAll:!0,compositeResult:!0},result:{__mapIndex:[0,1],test:[[1],[2]],map:[{test:[[[1]],[[1]]]},{test:[[[2]],[[2]]]}],row:[1,2]},graph:{nodes:{test:{agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}},map:{agent:"mapAgent",inputs:{rows:[":test",":test"]},params:{compositeResult:!0},graph:{nodes:{test:{isResult:!0,agent:"copyAgent",params:{namedKey:"rows"},inputs:{rows:[":row"]}}}}}}}}],description:"Map Agent",category:["graph"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},W=async({namedInputs:t,params:r})=>{const{flatResponse:s}=r;e.assert(a.isNamedInputs(t),"totalAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }"),e.assert(!!t?.array,"totalAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }");const n=t.array.reduce(((e,a)=>((Array.isArray(a)?a:[a]).forEach((a=>{Object.keys(a).forEach((t=>{const r=a[t];e[t]?e[t]+=r:e[t]=r}))})),e)),{});return s?n:{data:n}},Q={name:"totalAgent",agent:W,mock:W,inputs:{type:"object",properties:{array:{type:"array",description:"the array"}},required:["array"]},output:{type:"object"},samples:[{inputs:{array:[{a:1},{a:2},{a:3}]},params:{},result:{data:{a:6}}},{inputs:{array:[[{a:1,b:-1},{c:10}],[{a:2,b:-1}],[{a:3,b:-2},{d:-10}]]},params:{},result:{data:{a:6,b:-4,c:10,d:-10}}},{inputs:{array:[{a:1}]},params:{},result:{data:{a:1}}},{inputs:{array:[{a:1},{a:2}]},params:{},result:{data:{a:3}}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{},result:{data:{a:6}}},{inputs:{array:[{a:1,b:1},{a:2,b:2},{a:3,b:0}]},params:{},result:{data:{a:6,b:3}}},{inputs:{array:[{a:1},{a:2,b:2},{a:3,b:0}]},params:{},result:{data:{a:6,b:2}}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{flatResponse:!0},result:{a:6}},{inputs:{array:[[{a:1,b:-1},{c:10}],[{a:2,b:-1}],[{a:3,b:-2},{d:-10}]]},params:{flatResponse:!0},result:{a:6,b:-4,c:10,d:-10}},{inputs:{array:[{a:1}]},params:{flatResponse:!0},result:{a:1}},{inputs:{array:[{a:1},{a:2}]},params:{flatResponse:!0},result:{a:3}},{inputs:{array:[{a:1},{a:2},{a:3}]},params:{flatResponse:!0},result:{a:6}},{inputs:{array:[{a:1,b:1},{a:2,b:2},{a:3,b:0}]},params:{flatResponse:!0},result:{a:6,b:3}},{inputs:{array:[{a:1},{a:2,b:2},{a:3,b:0}]},params:{flatResponse:!0},result:{a:6,b:2}}],description:"Returns the sum of input values",category:["data"],author:"Satoshi Nakajima",repository:"https://github.com/snakajima/graphai",license:"MIT"},Z=async({namedInputs:t,params:r})=>{const{flatResponse:s}=r;e.assert(a.isNamedInputs(t),"dataSumTemplateAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }"),e.assert(!!t?.array,"dataSumTemplateAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }");const n=t.array.reduce(((e,a)=>e+a),0);return s?n:{result:n}},ee={name:"dataSumTemplateAgent",agent:Z,mock:Z,inputs:{type:"object",properties:{array:{type:"array",description:"the array of numbers to calculate the sum of",items:{type:"integer"}}},required:["array"]},output:{type:"number"},samples:[{inputs:{array:[1]},params:{},result:{result:1}},{inputs:{array:[1,2]},params:{},result:{result:3}},{inputs:{array:[1,2,3]},params:{},result:{result:6}},{inputs:{array:[1]},params:{flatResponse:!0},result:1},{inputs:{array:[1,2]},params:{flatResponse:!0},result:3},{inputs:{array:[1,2,3]},params:{flatResponse:!0},result:6}],description:"Returns the sum of input values",category:["data"],author:"Satoshi Nakajima",repository:"https://github.com/receptron/graphai",license:"MIT"},ae=(e,a,t,r,s,n,o,p,i)=>{const u=r||Object.keys(e),l=new Set(s??[]),m=u.reduce(((a,t)=>{if(!l.has(t)){const r=n&&n[t];r&&r[e[t]]?a[t]=r[e[t]]:a[t]=e[t]}return a}),{});return o&&o.forEach((e=>{void 0!==e.index&&e.index!==a||(m[e.propId]=t[e.from])})),i&&i.forEach((e=>{const a=t[e.from??1];e.equal?m[e.propId]=e.equal===a:e.notEqual&&(m[e.propId]=e.notEqual!==a)})),p&&Object.keys(p).forEach((e=>{const a=m[e];m[e]=m[p[e]],m[p[e]]=a})),m},te=async({namedInputs:e,params:a})=>{const{include:t,exclude:r,alter:s,inject:n,swap:o,inspect:p}=a,{array:i,item:u}=e;if(i){const[e]=i;return Array.isArray(e)?e.map(((e,a)=>ae(e,a,i,t,r,s,n,o,p))):ae(e,0,i,t,r,s,n,o,p)}return!!u&&ae(u,0,[],t,r,s,n,o,p)},re={array:[[{color:"red",model:"Model 3",type:"EV",maker:"Tesla",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400}],"Tesla Motors"]},se={name:"propertyFilterAgent",agent:te,mock:te,inputs:{type:"object"},output:{type:"any",properties:{array:{type:"array",description:"the array to apply filter"},item:{type:"object",description:"the object to apply filter"}}},samples:[{inputs:{array:[re.array[0][0]]},params:{include:["color","model"]},result:{color:"red",model:"Model 3"}},{inputs:{item:re.array[0][0]},params:{include:["color","model"]},result:{color:"red",model:"Model 3"}},{inputs:re,params:{include:["color","model"]},result:[{color:"red",model:"Model 3"},{color:"blue",model:"Model Y"}]},{inputs:re,params:{exclude:["color","model"]},result:[{type:"EV",maker:"Tesla",range:300},{type:"EV",maker:"Tesla",range:400}]},{inputs:{item:re.array[0][0]},params:{exclude:["color","model"]},result:{type:"EV",maker:"Tesla",range:300}},{inputs:re,params:{alter:{color:{red:"blue",blue:"red"}}},result:[{color:"blue",model:"Model 3",type:"EV",maker:"Tesla",range:300},{color:"red",model:"Model Y",type:"EV",maker:"Tesla",range:400}]},{inputs:{item:re.array[0][0]},params:{alter:{color:{red:"blue",blue:"red"}}},result:{color:"blue",model:"Model 3",type:"EV",maker:"Tesla",range:300}},{inputs:re,params:{swap:{maker:"model"}},result:[{color:"red",model:"Tesla",type:"EV",maker:"Model 3",range:300},{color:"blue",model:"Tesla",type:"EV",maker:"Model Y",range:400}]},{inputs:{item:re.array[0][0]},params:{swap:{maker:"model"}},result:{color:"red",model:"Tesla",type:"EV",maker:"Model 3",range:300}},{inputs:re,params:{inject:[{propId:"maker",from:1}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla Motors",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla Motors",range:400}]},{inputs:re,params:{inject:[{propId:"maker",from:1,index:0}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla Motors",range:300},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400}]},{inputs:re,params:{inspect:[{propId:"isTesla",equal:"Tesla Motors"},{propId:"isGM",notEqual:"Tesla Motors",from:1}]},result:[{color:"red",model:"Model 3",type:"EV",maker:"Tesla",range:300,isTesla:!0,isGM:!1},{color:"blue",model:"Model Y",type:"EV",maker:"Tesla",range:400,isTesla:!0,isGM:!1}]}],description:"Filter properties based on property name either with 'include', 'exclude', 'alter', 'swap', 'inject', 'inspect'",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},ne=async({namedInputs:t,params:r})=>{const{namedKey:s}=r;return e.assert(a.isNamedInputs(t),"copyAgent: namedInputs is UNDEFINED!"),s?t[s]:t},oe={name:"copyAgent",agent:ne,mock:ne,inputs:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},output:{anyOf:[{type:"string"},{type:"integer"},{type:"object"},{type:"array"}]},samples:[{inputs:{color:"red",model:"Model 3"},params:{},result:{color:"red",model:"Model 3"}},{inputs:{array:["Hello World","Discarded"]},params:{},result:{array:["Hello World","Discarded"]}},{inputs:{color:"red",model:"Model 3"},params:{namedKey:"color"},result:"red"}],description:"Returns namedInputs",category:["data"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},pe=async({namedInputs:e,params:a})=>{const{url:t,method:r,queryParams:s,headers:n,body:o}=e,p=a.throwError??!1,i=new URL(t),u=n?{...n}:{};if(s){const e=new URLSearchParams(s);i.search=e.toString()}o&&(u["Content-Type"]="application/json");const l={method:r??o?"POST":"GET",headers:new Headers(u),body:o?JSON.stringify(o):void 0};if(a?.debug)return{url:i.toString(),method:l.method,headers:u,body:l.body};const m=await fetch(i.toString(),l);if(!m.ok){const e=m.status,t="json"===(a?.type??"json")?await m.json():await m.text();if(p)throw new Error(`HTTP error: ${e}`);return{onError:{message:`HTTP error: ${e}`,status:e,error:t}}}return await(async()=>{const e=a?.type??"json";if("json"===e)return await m.json();if("text"===e)return m.text();throw new Error(`Unknown Type! ${e}`)})()},ie={name:"vanillaFetchAgent",agent:pe,mock:pe,inputs:{type:"object",properties:{url:{type:"string",description:"baseurl"},method:{type:"string",description:"HTTP method"},headers:{type:"object",description:"HTTP headers"},quaryParams:{type:"object",description:"Query parameters"},body:{anyOf:[{type:"string"},{type:"object"}],description:"body"}},required:["url"]},output:{type:"array"},samples:[{inputs:{url:"https://www.google.com",queryParams:{foo:"bar"},headers:{"x-myHeader":"secret"}},params:{debug:!0},result:{method:"GET",url:"https://www.google.com/?foo=bar",headers:{"x-myHeader":"secret"},body:void 0}},{inputs:{url:"https://www.google.com",body:{foo:"bar"}},params:{debug:!0},result:{method:"POST",url:"https://www.google.com/",headers:{"Content-Type":"application/json"},body:JSON.stringify({foo:"bar"})}}],description:"Retrieves JSON data from the specified URL",category:["service"],author:"Receptron",repository:"https://github.com/receptron/graphai",license:"MIT"},ue=async({params:a,namedInputs:t})=>(await e.sleep(a?.duration??10),t),le={name:"sleeperAgent",agent:ue,mock:ue,samples:[{inputs:{},params:{duration:1},result:{}},{inputs:{array:[{a:1},{b:2}]},params:{duration:1},result:{array:[{a:1},{b:2}]}}],description:"sleeper Agent",category:["sleeper"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"},me=e=>{const a=e.map((e=>Array.isArray(e)?me(e):e)),[t,r,s]=a;if("=="===r)return t===s;if("!="===r)return t!==s;if(">"===r)return Number(t)>Number(s);if(">="===r)return Number(t)>=Number(s);if("<"===r)return Number(t)<Number(s);if("<="===r)return Number(t)<=Number(s);if("||"===r)return!!t||!!s;if("&&"===r)return!!t&&!!s;if("XOR"===r)return!!t==!s;throw new Error("unknown compare operator")},ce=e=>null==e,ye=async({namedInputs:e,params:a})=>{const{array:t,leftValue:r,rightValue:s}=e,n=t??[],o=(()=>{if(2===n.length&&a.operator)return[n[0],a.operator,n[1]];if(3===n.length)return e.array;if(0===n.length&&!ce(r)&&!ce(s)&&a.operator)return[r,a.operator,s];throw new Error("compare inputs is wrong.")})(),p=me(o);return a?.value?{result:a?.value[p?"true":"false"]??p}:{result:p}},ge={name:"compareAgent",agent:ye,mock:ye,inputs:{},output:{},samples:[{inputs:{array:["abc","==","abc"]},params:{value:{true:"a",false:"b"}},result:{result:"a"}},{inputs:{array:["abc","==","abca"]},params:{value:{true:"a",false:"b"}},result:{result:"b"}},{inputs:{array:["abc","==","abc"]},params:{},result:{result:!0}},{inputs:{array:["abc","==","abcd"]},params:{},result:{result:!1}},{inputs:{array:["abc","!=","abc"]},params:{},result:{result:!1}},{inputs:{array:["abc","!=","abcd"]},params:{},result:{result:!0}},{inputs:{array:["10",">","5"]},params:{},result:{result:!0}},{inputs:{array:["10",">","15"]},params:{},result:{result:!1}},{inputs:{array:[10,">",5]},params:{},result:{result:!0}},{inputs:{array:[10,">",15]},params:{},result:{result:!1}},{inputs:{array:["10",">=","5"]},params:{},result:{result:!0}},{inputs:{array:["10",">=","10"]},params:{},result:{result:!0}},{inputs:{array:["10",">=","19"]},params:{},result:{result:!1}},{inputs:{array:[10,">=",5]},params:{},result:{result:!0}},{inputs:{array:[10,">=",10]},params:{},result:{result:!0}},{inputs:{array:[10,">=",19]},params:{},result:{result:!1}},{inputs:{array:["10","<","5"]},params:{},result:{result:!1}},{inputs:{array:["10","<","15"]},params:{},result:{result:!0}},{inputs:{array:[10,"<",5]},params:{},result:{result:!1}},{inputs:{array:[10,"<",15]},params:{},result:{result:!0}},{inputs:{array:["10","<=","5"]},params:{},result:{result:!1}},{inputs:{array:["10","<=","10"]},params:{},result:{result:!0}},{inputs:{array:["10","<=","19"]},params:{},result:{result:!0}},{inputs:{array:[10,"<=",5]},params:{},result:{result:!1}},{inputs:{array:[10,"<=",10]},params:{},result:{result:!0}},{inputs:{array:[10,"<=",19]},params:{},result:{result:!0}},{inputs:{array:[!0,"||",!1]},params:{},result:{result:!0}},{inputs:{array:[!1,"||",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"&&",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"&&",!0]},params:{},result:{result:!0}},{inputs:{array:[!0,"XOR",!1]},params:{},result:{result:!0}},{inputs:{array:[!1,"XOR",!0]},params:{},result:{result:!0}},{inputs:{array:[!1,"XOR",!1]},params:{},result:{result:!1}},{inputs:{array:[!0,"XOR",!0]},params:{},result:{result:!1}},{inputs:{array:[["aaa","==","aaa"],"||",["aaa","==","bbb"]]},params:{},result:{result:!0}},{inputs:{array:[["aaa","==","aaa"],"&&",["aaa","==","bbb"]]},params:{},result:{result:!1}},{inputs:{array:[[["aaa","==","aaa"],"&&",["bbb","==","bbb"]],"||",["aaa","&&","bbb"]]},params:{},result:{result:!0}},{inputs:{array:["abc","abc"]},params:{value:{true:"a",false:"b"},operator:"=="},result:"a"},{inputs:{array:["abc","abca"]},params:{value:{true:"a",false:"b"},operator:"=="},result:"b"},{inputs:{array:["abc","abc"]},params:{operator:"=="},result:!0},{inputs:{array:["abc","abcd"]},params:{operator:"=="},result:!1},{inputs:{array:["abc","abc"]},params:{operator:"!="},result:!1},{inputs:{array:["abc","abcd"]},params:{operator:"!="},result:!0},{inputs:{array:["10","5"]},params:{operator:">"},result:!0},{inputs:{array:["10","15"]},params:{operator:">"},result:!1},{inputs:{array:[10,5]},params:{operator:">"},result:!0},{inputs:{array:[10,15]},params:{operator:">"},result:!1},{inputs:{array:["10","5"]},params:{operator:">="},result:!0},{inputs:{array:["10","10"]},params:{operator:">="},result:!0},{inputs:{array:["10","19"]},params:{operator:">="},result:!1},{inputs:{array:[10,5]},params:{operator:">="},result:!0},{inputs:{array:[10,10]},params:{operator:">="},result:!0},{inputs:{array:[10,19]},params:{operator:">="},result:!1},{inputs:{array:["10","5"]},params:{operator:"<"},result:!1},{inputs:{array:["10","15"]},params:{operator:"<"},result:!0},{inputs:{array:[10,5]},params:{operator:"<"},result:!1},{inputs:{array:[10,15]},params:{operator:"<"},result:!0},{inputs:{array:[!0,!1]},params:{operator:"||"},result:!0},{inputs:{array:[!1,!1]},params:{operator:"||"},result:!1},{inputs:{array:[!0,!1]},params:{operator:"&&"},result:!1},{inputs:{array:[!0,!0]},params:{operator:"&&"},result:!0},{inputs:{array:[!0,!1]},params:{operator:"XOR"},result:!0},{inputs:{array:[!1,!0]},params:{operator:"XOR"},result:!0},{inputs:{array:[!1,!1]},params:{operator:"XOR"},result:!1},{inputs:{array:[!0,!0]},params:{operator:"XOR"},result:!1},{inputs:{leftValue:"abc",rightValue:"abc"},params:{value:{true:"a",false:"b"},operator:"=="},result:"a"},{inputs:{leftValue:"abc",rightValue:"abca"},params:{value:{true:"a",false:"b"},operator:"=="},result:"b"}],description:"compare",category:["compare"],author:"Receptron",repository:"https://github.com/receptron/graphai",license:"MIT"},de=async({namedInputs:t,params:r})=>{const{imageType:s,detail:n}=r,{array:o,prompt:p}=t;a.arrayValidate("images2messageAgent",t),e.assert(!!s,"images2messageAgent: params.imageType is UNDEFINED! Set Type: png, jpg...");const i=o.map((e=>{const a=((e,a,t)=>"http"===a?{url:e}:{url:`data:image/${a};base64,${e}`,detail:t??"auto"})(e,s,n);return{type:"image_url",image_url:a}}));return p&&i.unshift({type:"text",text:p}),{message:{role:"user",content:i}}},he={name:"images2messageAgent",agent:de,mock:de,inputs:{type:"object",properties:{array:{type:"array",description:"the array of base64 image data"},prompt:{type:"string",description:"prompt message"}},required:["array"]},output:{type:"object"},samples:[{inputs:{array:["abcabc","122123"]},params:{imageType:"png"},result:{message:{content:[{image_url:{detail:"auto",url:"data:image/png;base64,abcabc"},type:"image_url"},{image_url:{detail:"auto",url:"data:image/png;base64,122123"},type:"image_url"}],role:"user"}}},{inputs:{array:["abcabc","122123"],prompt:"hello"},params:{imageType:"jpg",detail:"high"},result:{message:{content:[{type:"text",text:"hello"},{image_url:{detail:"high",url:"data:image/jpg;base64,abcabc"},type:"image_url"},{image_url:{detail:"high",url:"data:image/jpg;base64,122123"},type:"image_url"}],role:"user"}}},{inputs:{array:["http://example.com/1.jpg","http://example.com/2.jpg"]},params:{imageType:"http"},result:{message:{content:[{image_url:{url:"http://example.com/1.jpg"},type:"image_url"},{image_url:{url:"http://example.com/2.jpg"},type:"image_url"}],role:"user"}}}],description:"Returns the message data for llm include image",category:["image"],author:"Receptron team",repository:"https://github.com/snakajima/graphai",license:"MIT"},be=async({params:e,namedInputs:a})=>{const{array:t,item:r}=a,s=t??[r],n=process.env.OPENAI_API_KEY;if(!n)throw new Error("OPENAI_API_KEY key is not set in environment variables.");const o={"Content-Type":"application/json",Authorization:`Bearer ${n}`},p=await fetch("https://api.openai.com/v1/embeddings",{method:"POST",headers:o,body:JSON.stringify({input:s,model:e?.model??"text-embedding-3-small"})}),i=await p.json();if(!p.ok)throw new Error(`HTTP error! status: ${p.status}`);return i.data.map((e=>e.embedding))},fe={name:"stringEmbeddingsAgent",agent:be,mock:be,samples:[],description:"Embeddings Agent",category:["embedding"],author:"Receptron team",repository:"https://github.com/receptron/graphai",license:"MIT"};exports.arrayFlatAgent=M,exports.arrayJoinAgent=O,exports.compareAgent=ge,exports.copy2ArrayAgent=J,exports.copyAgent=oe,exports.copyMessageAgent=z,exports.countingAgent=F,exports.dataSumTemplateAgent=ee,exports.dotProductAgent=V,exports.echoAgent=q,exports.images2messageAgent=he,exports.jsonParserAgent=g,exports.mapAgent=B,exports.mergeNodeIdAgent=L,exports.nestedAgent=w,exports.popAgent=j,exports.propertyFilterAgent=se,exports.pushAgent=k,exports.shiftAgent=N,exports.sleeperAgent=le,exports.sortByValuesAgent=P,exports.streamMockAgent=H,exports.stringCaseVariantsAgent=h,exports.stringEmbeddingsAgent=fe,exports.stringSplitterAgent=r,exports.stringTemplateAgent=p,exports.stringUpdateTextAgent=x,exports.totalAgent=Q,exports.vanillaFetchAgent=ie;
//# sourceMappingURL=bundle.cjs.min.js.map
