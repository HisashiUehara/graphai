{"version":3,"file":"bundle.esm.min.js","sources":["../src/string_agents/string_splitter_agent.ts","../src/string_agents/string_template_agent.ts","../src/string_agents/json_parser_agent.ts","../../agent_utils/lib/index.js","../src/array_agents/push_agent.ts","../src/array_agents/pop_agent.ts","../src/array_agents/shift_agent.ts","../src/array_agents/array_flat_agent.ts","../src/array_agents/array_join_agent.ts","../src/matrix_agents/dot_product_agent.ts","../src/matrix_agents/sort_by_values_agent.ts","../src/test_agents/echo_agent.ts","../src/test_agents/counting_agent.ts","../src/test_agents/copy_message_agent.ts","../src/test_agents/copy2array_agent.ts","../src/test_agents/merge_node_id_agent.ts","../src/test_agents/stream_mock_agent.ts","../src/graph_agents/nested_agent.ts","../src/graph_agents/map_agent.ts","../src/data_agents/total_agent.ts","../src/data_agents/data_sum_template_agent.ts","../src/data_agents/property_filter_agent.ts","../src/data_agents/copy_agent.ts","../src/service_agents/vanilla_fetch_agent.ts","../src/sleeper_agents/sleeper_agent.ts","../src/compare_agents/compare_agent.ts","../src/embedding_agent.ts"],"sourcesContent":["import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\n\n// This agent strip one long string into chunks using following parameters\n//\n//  chunkSize: number; // default is 2048\n//  overlap: number;   // default is 1/8th of chunkSize.\n//\n// see example\n//  tests/agents/test_string_agent.ts\n//\nconst defaultChunkSize = 2048;\n\nexport const stringSplitterAgent: AgentFunction<\n  {\n    chunkSize?: number;\n    overlap?: number;\n  },\n  {\n    contents: Array<string>;\n    count: number;\n    chunkSize: number;\n    overlap: number;\n  },\n  null,\n  {\n    text: string;\n  }\n> = async ({ params, namedInputs }) => {\n  assert(!!namedInputs, \"stringSplitterAgent: namedInputs is UNDEFINED!\");\n  const source = namedInputs.text;\n  const chunkSize = params.chunkSize ?? defaultChunkSize;\n  const overlap = params.overlap ?? Math.floor(chunkSize / 8);\n  const count = Math.floor(source.length / (chunkSize - overlap)) + 1;\n  const contents = new Array(count).fill(undefined).map((_, i) => {\n    const startIndex = i * (chunkSize - overlap);\n    return source.substring(startIndex, startIndex + chunkSize);\n  });\n\n  return { contents, count, chunkSize, overlap };\n};\n\n// for test and document\nconst sampleInput = {\n  text: \"Here's to the crazy ones, the misfits, the rebels, the troublemakers, the round pegs in the square holes ... the ones who see things differently -- they're not fond of rules, and they have no respect for the status quo. ... You can quote them, disagree with them, glorify or vilify them, but the only thing you can't do is ignore them because they change things. ... They push the human race forward, and while some may see them as the crazy ones, we see genius, because the people who are crazy enough to think that they can change the world, are the ones who do.\",\n};\n\nconst sampleParams = { chunkSize: 64 };\nconst sampleResult = {\n  contents: [\n    \"Here's to the crazy ones, the misfits, the rebels, the troublema\",\n    \"roublemakers, the round pegs in the square holes ... the ones wh\",\n    \" ones who see things differently -- they're not fond of rules, a\",\n    \"rules, and they have no respect for the status quo. ... You can \",\n    \"You can quote them, disagree with them, glorify or vilify them, \",\n    \"y them, but the only thing you can't do is ignore them because t\",\n    \"ecause they change things. ... They push the human race forward,\",\n    \"forward, and while some may see them as the crazy ones, we see g\",\n    \"we see genius, because the people who are crazy enough to think \",\n    \"o think that they can change the world, are the ones who do.\",\n    \" do.\",\n  ],\n  count: 11,\n  chunkSize: 64,\n  overlap: 8,\n};\n\nconst stringSplitterAgentInfo: AgentFunctionInfo = {\n  name: \"stringSplitterAgent\",\n  agent: stringSplitterAgent,\n  mock: stringSplitterAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      text: {\n        type: \"string\",\n        description: \"text to be chuncked\",\n      },\n    },\n    required: [\"text\"],\n  },\n  output: {\n    type: \"object\",\n    properties: {\n      contents: {\n        type: \"array\",\n        description: \"the array of text chunks\",\n      },\n      count: {\n        type: \"number\",\n        description: \"the number of chunks\",\n      },\n      chunkSize: {\n        type: \"number\",\n        description: \"the chunk size\",\n      },\n      overlap: {\n        type: \"number\",\n        description: \"the overlap size\",\n      },\n    },\n  },\n  samples: [\n    {\n      inputs: sampleInput,\n      params: sampleParams,\n      result: sampleResult,\n    },\n  ],\n  description: \"This agent strip one long string into chunks using following parameters\",\n  category: [\"string\"],\n  author: \"Satoshi Nakajima\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default stringSplitterAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, isObject } from \"graphai\";\n\ntype StringTemplate = string | Record<string, string>;\ntype StringTemplateObject = StringTemplate | StringTemplate[] | Record<string, StringTemplate>;\n\nconst processTemplate: any = (template: StringTemplateObject, match: string, input: string) => {\n  if (typeof template === \"string\") {\n    if (template === match) {\n      return input;\n    }\n    return template.replace(match, input);\n  } else if (Array.isArray(template)) {\n    return template.map((item: StringTemplate) => processTemplate(item, match, input));\n  }\n\n  if (isObject(template)) {\n    return Object.keys(template).reduce((tmp: any, key: string) => {\n      tmp[key] = processTemplate(template[key], match, input);\n      return tmp;\n    }, {});\n  }\n  return template;\n};\n\nexport const stringTemplateAgent: AgentFunction<\n  {\n    template: StringTemplateObject;\n  },\n  StringTemplateObject,\n  string,\n  Record<string, string>\n> = async ({ params, inputs, namedInputs }) => {\n  if (params.template === undefined) {\n    if (namedInputs.text) {\n      return namedInputs.text;\n    }\n    console.warn(\"warning: stringTemplateAgent no template\");\n  }\n  if (inputs && inputs.length > 0) {\n    return inputs.reduce((template, input, index) => {\n      return processTemplate(template, \"${\" + index + \"}\", input);\n    }, params.template);\n  }\n  return Object.keys(namedInputs).reduce((template, key) => {\n    return processTemplate(template, \"${\" + key + \"}\", namedInputs[key]);\n  }, params.template);\n};\n\nconst sampleNamedInput = { message1: \"hello\", message2: \"test\" };\n\n// for test and document\nconst stringTemplateAgentInfo: AgentFunctionInfo = {\n  name: \"stringTemplateAgent\",\n  agent: stringTemplateAgent,\n  mock: stringTemplateAgent,\n  samples: [\n    // named\n    {\n      inputs: sampleNamedInput,\n      params: { template: \"${message1}: ${message2}\" },\n      result: \"hello: test\",\n    },\n    {\n      inputs: sampleNamedInput,\n      params: { template: [\"${message1}: ${message2}\", \"${message2}: ${message1}\"] },\n      result: [\"hello: test\", \"test: hello\"],\n    },\n    {\n      inputs: sampleNamedInput,\n      params: { template: { apple: \"${message1}\", lemon: \"${message2}\" } },\n      result: { apple: \"hello\", lemon: \"test\" },\n    },\n    {\n      inputs: sampleNamedInput,\n      params: { template: [{ apple: \"${message1}\", lemon: \"${message2}\" }] },\n      result: [{ apple: \"hello\", lemon: \"test\" }],\n    },\n    {\n      inputs: sampleNamedInput,\n      params: { template: { apple: \"${message1}\", lemon: [\"${message2}\"] } },\n      result: { apple: \"hello\", lemon: [\"test\"] },\n    },\n    // graphData\n    {\n      inputs: { agent: \"openAiAgent\", row: \"hello world\", params: { text: \"message\" } },\n      params: {\n        template: {\n          version: 0.5,\n          nodes: {\n            ai: {\n              agent: \"${agent}\",\n              isResult: true,\n              params: \"${params}\",\n              inputs: { prompt: \"${row}\" },\n            },\n          },\n        },\n      },\n      result: {\n        nodes: {\n          ai: {\n            agent: \"openAiAgent\",\n            inputs: {\n              prompt: \"hello world\",\n            },\n            isResult: true,\n            params: { text: \"message\" },\n          },\n        },\n        version: 0.5,\n      },\n    },\n  ],\n  description: \"Template agent\",\n  category: [\"string\"],\n  author: \"Satoshi Nakajima\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default stringTemplateAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\nexport const jsonParserAgent: AgentFunction<\n  null,\n  unknown,\n  null,\n  {\n    text: string;\n    data: unknown;\n  }\n> = async ({ namedInputs }) => {\n  const { text, data } = namedInputs;\n\n  if (data) {\n    return JSON.stringify(data, null, 2);\n  }\n  const match = (\"\\n\" + text).match(/\\n```[a-zA-z]*([\\s\\S]*?)\\n```/);\n  if (match) {\n    return JSON.parse(match[1]);\n  }\n  return JSON.parse(text);\n};\n\nconst sample_object = { apple: \"red\", lemon: \"yellow\" };\n\nconst json_str = JSON.stringify(sample_object);\nconst md_json1 = [\"```\", json_str, \"```\"].join(\"\\n\");\n\nconst md_json2 = [\"```json\", json_str, \"```\"].join(\"\\n\");\n\nconst md_json3 = [\"```JSON\", json_str, \"```\"].join(\"\\n\");\n\nconst jsonParserAgentInfo: AgentFunctionInfo = {\n  name: \"jsonParserAgent\",\n  agent: jsonParserAgent,\n  mock: jsonParserAgent,\n  inputs: {\n    anyOf: [{ type: \"string\" }, { type: \"integer\" }, { type: \"object\" }, { type: \"array\" }],\n  },\n  output: {\n    type: \"string\",\n  },\n  samples: [\n    {\n      inputs: { data: sample_object },\n      params: {},\n      result: JSON.stringify(sample_object, null, 2),\n    },\n    {\n      inputs: { text: JSON.stringify(sample_object, null, 2) },\n      params: {},\n      result: sample_object,\n    },\n    {\n      inputs: { text: md_json1 },\n      params: {},\n      result: sample_object,\n    },\n    {\n      inputs: { text: md_json2 },\n      params: {},\n      result: sample_object,\n    },\n    {\n      inputs: { text: md_json3 },\n      params: {},\n      result: sample_object,\n    },\n  ],\n  description: \"Template agent\",\n  category: [\"string\"],\n  author: \"Satoshi Nakajima\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default jsonParserAgentInfo;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNamedInputs = exports.sample2GraphData = void 0;\nconst sample2GraphData = (sample, agentName) => {\n    const nodes = {};\n    const inputs = (() => {\n        if (Array.isArray(sample.inputs)) {\n            Array.from(sample.inputs.keys()).forEach((key) => {\n                nodes[\"sampleInput\" + key] = {\n                    value: sample.inputs[key],\n                };\n            });\n            return Object.keys(nodes).map((k) => \":\" + k);\n        }\n        nodes[\"sampleInput\"] = {\n            value: sample.inputs,\n        };\n        return Object.keys(sample.inputs).reduce((tmp, key) => {\n            tmp[key] = `:sampleInput.` + key;\n            return tmp;\n        }, {});\n    })();\n    nodes[\"node\"] = {\n        isResult: true,\n        agent: agentName,\n        params: sample.params,\n        inputs: inputs,\n        graph: sample.graph,\n    };\n    const graphData = {\n        version: 0.5,\n        nodes,\n    };\n    return graphData;\n};\nexports.sample2GraphData = sample2GraphData;\nconst isNamedInputs = (namedInputs) => {\n    return Object.keys(namedInputs || {}).length > 0;\n};\nexports.isNamedInputs = isNamedInputs;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\nimport { isNamedInputs } from \"@graphai/agent_utils\";\n\nexport const pushAgent: AgentFunction<null, { array: Array<unknown> }, null, { array: Array<unknown>; item?: unknown; items: Array<unknown> }> = async ({\n  namedInputs,\n}) => {\n  assert(isNamedInputs(namedInputs), \"pushAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId, item: :itemNodeId }\");\n  const { item, items } = namedInputs;\n  assert(!!namedInputs.array, \"pushAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId, item: :itemNodeId }\");\n  assert(!!(item || items), \"pushAgent: namedInputs.item is UNDEFINED! Set inputs: { array: :arrayNodeId, item: :itemNodeId }\");\n\n  const array = namedInputs.array.map((item: any) => item); // shallow copy\n  if (item) {\n    array.push(item);\n  } else {\n    items.forEach((item) => {\n      array.push(item);\n    });\n  }\n  return {\n    array,\n  };\n};\n\nconst pushAgentInfo: AgentFunctionInfo = {\n  name: \"pushAgent\",\n  agent: pushAgent,\n  mock: pushAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the array to push an item to\",\n      },\n      item: {\n        anyOf: [{ type: \"string\" }, { type: \"integer\" }, { type: \"object\" }, { type: \"array\" }],\n        description: \"the item push into the array\",\n      },\n      items: {\n        anyOf: [{ type: \"string\" }, { type: \"integer\" }, { type: \"object\" }, { type: \"array\" }],\n        description: \"the item push into the array\",\n      },\n    },\n    required: [\"array\"],\n  },\n  output: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n      },\n    },\n  },\n  samples: [\n    {\n      inputs: { array: [1, 2], item: 3 },\n      params: {},\n      result: { array: [1, 2, 3] },\n    },\n    {\n      inputs: { array: [{ apple: 1 }], item: { lemon: 2 } },\n      params: {},\n      result: { array: [{ apple: 1 }, { lemon: 2 }] },\n    },\n    {\n      inputs: { array: [{ apple: 1 }], items: [{ lemon: 2 }, { banana: 3 }] },\n      params: {},\n      result: { array: [{ apple: 1 }, { lemon: 2 }, { banana: 3 }] },\n    },\n  ],\n  description: \"push Agent\",\n  category: [\"array\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default pushAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\nimport { isNamedInputs } from \"@graphai/agent_utils\";\n\nexport const popAgent: AgentFunction<null, { array: Array<unknown>; item: unknown }, null, { array: Array<unknown> }> = async ({ namedInputs }) => {\n  assert(isNamedInputs(namedInputs), \"popAgent: namedInputs is UNDEFINED!\");\n  assert(!!namedInputs.array, \"popAgent: namedInputs.array is UNDEFINED!\");\n\n  const array = namedInputs.array.map((item: any) => item); // shallow copy\n  const item = array.pop();\n  return { array, item };\n};\n\nconst popAgentInfo: AgentFunctionInfo = {\n  name: \"popAgent\",\n  agent: popAgent,\n  mock: popAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the array to pop an item from\",\n      },\n    },\n    required: [\"array\"],\n  },\n  output: {\n    type: \"object\",\n    properties: {\n      item: {\n        anyOf: [{ type: \"string\" }, { type: \"integer\" }, { type: \"object\" }, { type: \"array\" }],\n        description: \"the item popped from the array\",\n      },\n      array: {\n        type: \"array\",\n        description: \"the remaining array\",\n      },\n    },\n  },\n  samples: [\n    {\n      inputs: { array: [1, 2, 3] },\n      params: {},\n      result: {\n        array: [1, 2],\n        item: 3,\n      },\n    },\n    {\n      inputs: { array: [\"a\", \"b\", \"c\"] },\n      params: {},\n      result: {\n        array: [\"a\", \"b\"],\n        item: \"c\",\n      },\n    },\n    {\n      inputs: {\n        array: [1, 2, 3],\n        array2: [\"a\", \"b\", \"c\"],\n      },\n      params: {},\n      result: {\n        array: [1, 2],\n        item: 3,\n      },\n    },\n  ],\n  description: \"Pop Agent\",\n  category: [\"array\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default popAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\n\nexport const shiftAgent: AgentFunction<Record<string, any>, Record<string, any>, Array<any>> = async ({ namedInputs }) => {\n  assert(!!namedInputs, \"shiftAgent: namedInputs is UNDEFINED!\");\n  const array = namedInputs.array.map((item: any) => item); // shallow copy\n  const item = array.shift();\n  return { array, item };\n};\n\nconst shiftAgentInfo: AgentFunctionInfo = {\n  name: \"shiftAgent\",\n  agent: shiftAgent,\n  mock: shiftAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the array to shift an item from\",\n      },\n    },\n    required: [\"array\"],\n  },\n  output: {\n    type: \"object\",\n    properties: {\n      item: {\n        anyOf: [{ type: \"string\" }, { type: \"integer\" }, { type: \"object\" }, { type: \"array\" }],\n        description: \"the item shifted from the array\",\n      },\n      array: {\n        type: \"array\",\n        description: \"the remaining array\",\n      },\n    },\n  },\n  samples: [\n    {\n      inputs: { array: [1, 2, 3] },\n      params: {},\n      result: {\n        array: [2, 3],\n        item: 1,\n      },\n    },\n    {\n      inputs: { array: [\"a\", \"b\", \"c\"] },\n      params: {},\n      result: {\n        array: [\"b\", \"c\"],\n        item: \"a\",\n      },\n    },\n  ],\n  description: \"shift Agent\",\n  category: [\"array\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default shiftAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\n\nexport const arrayFlatAgent: AgentFunction<{ depth?: number }, { array: Array<unknown> }, Array<never>, { array: Array<unknown> }> = async ({\n  namedInputs,\n  params,\n}) => {\n  assert(!!namedInputs, \"arrayFlatAgent: namedInputs is UNDEFINED!\");\n  const depth = params.depth ?? 1;\n\n  const array = namedInputs.array.map((item: any) => item); // shallow copy\n  return { array: array.flat(depth) };\n};\n\nconst arrayFlatAgentInfo: AgentFunctionInfo = {\n  name: \"arrayFlatAgent\",\n  agent: arrayFlatAgent,\n  mock: arrayFlatAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"flat array\",\n      },\n    },\n    required: [\"array\"],\n  },\n  output: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the remaining array\",\n      },\n    },\n  },\n  params: {\n    type: \"object\",\n    properties: {\n      depth: {\n        type: \"number\",\n        description: \"array depth\",\n      },\n    },\n  },\n  samples: [\n    {\n      inputs: { array: [[1], [2], [3]] },\n      params: {},\n      result: {\n        array: [1, 2, 3],\n      },\n    },\n    {\n      inputs: { array: [[1], [2], [[3]]] },\n      params: {},\n      result: {\n        array: [1, 2, [3]],\n      },\n    },\n    {\n      inputs: { array: [[1], [2], [[3]]] },\n      params: { depth: 2 },\n      result: {\n        array: [1, 2, 3],\n      },\n    },\n    {\n      inputs: { array: [[\"a\"], [\"b\"], [\"c\"]] },\n      params: {},\n      result: {\n        array: [\"a\", \"b\", \"c\"],\n      },\n    },\n  ],\n  description: \"Array Flat Agent\",\n  category: [\"array\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default arrayFlatAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\n\nexport const arrayJoinAgent: AgentFunction<{ separator?: string; flat?: number }, { text: string }, Array<never>, { array: Array<unknown> }> = async ({\n  namedInputs,\n  params,\n}) => {\n  assert(!!namedInputs, \"arrayJoinAgent: namedInputs is UNDEFINED!\");\n  assert(!!namedInputs.array, \"arrayJoinAgent: namedInputs.array is UNDEFINED!\");\n\n  const separator = params.separator ?? \"\";\n  const { flat } = params;\n\n  const text = flat ? namedInputs.array.flat(flat).join(separator) : namedInputs.array.join(separator);\n  return { text };\n};\n\nconst arrayJoinAgentInfo: AgentFunctionInfo = {\n  name: \"arrayJoinAgent\",\n  agent: arrayJoinAgent,\n  mock: arrayJoinAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"array join\",\n      },\n    },\n    required: [\"array\"],\n  },\n  params: {\n    type: \"object\",\n    properties: {\n      separator: {\n        type: \"string\",\n        description: \"array join separator\",\n      },\n      flat: {\n        type: \"number\",\n        description: \"array flat depth\",\n      },\n    },\n  },\n  output: {\n    type: \"object\",\n    properties: {\n      text: {\n        type: \"string\",\n        description: \"joined text\",\n      },\n    },\n  },\n  samples: [\n    {\n      inputs: { array: [[1], [2], [3]] },\n      params: {},\n      result: {\n        text: \"123\",\n      },\n    },\n    {\n      inputs: { array: [[1], [2], [[3]]] },\n      params: {},\n      result: {\n        text: \"123\",\n      },\n    },\n    {\n      inputs: { array: [[\"a\"], [\"b\"], [\"c\"]] },\n      params: {},\n      result: {\n        text: \"abc\",\n      },\n    },\n    //\n    {\n      inputs: { array: [[1], [2], [3]] },\n      params: { separator: \"|\" },\n      result: {\n        text: \"1|2|3\",\n      },\n    },\n    {\n      inputs: { array: [[[1]], [[2], [3]]] },\n      params: { separator: \"|\" },\n      result: {\n        text: \"1|2,3\",\n      },\n    },\n    {\n      inputs: { array: [[[1]], [[2], [3]]] },\n      params: { separator: \"|\", flat: 1 },\n      result: {\n        text: \"1|2|3\",\n      },\n    },\n    {\n      inputs: { array: [[[[1]], [[2], [3]]]] },\n      params: { separator: \"|\", flat: 1 },\n      result: {\n        text: \"1|2,3\",\n      },\n    },\n    {\n      inputs: { array: [[[[1]], [[2], [3]]]] },\n      params: { separator: \"|\", flat: 2 },\n      result: {\n        text: \"1|2|3\",\n      },\n    },\n  ],\n  description: \"Array Join Agent\",\n  category: [\"array\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default arrayJoinAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\n\n// This agent calculates the dot product of an array of vectors (A[]) and a vector (B),\n// typically used to calculate cosine similarity of embedding vectors.\n// Inputs:\n//  matrix: Two dimentional array of numbers.\n//  vector: One dimentional array of numbers.\n// Outputs:\n//  { contents: Array<number> } // array of docProduct of each vector (A[]) and vector B\nexport const dotProductAgent: AgentFunction<Record<never, never>, Array<number>, null, { matrix: Array<Array<number>>; vector: Array<number> }> = async ({\n  namedInputs,\n}) => {\n  assert(!!namedInputs, \"dotProductAgent: namedInputs is UNDEFINED!\");\n  const matrix = namedInputs.matrix as Array<Array<number>>;\n  const vector = namedInputs.vector as Array<number>;\n  if (matrix[0].length != vector.length) {\n    throw new Error(`dotProduct: Length of vectors do not match. ${matrix[0].length}, ${vector.length}`);\n  }\n  const contents = matrix.map((vector0) => {\n    return vector0.reduce((dotProduct: number, value, index) => {\n      return dotProduct + value * vector[index];\n    }, 0);\n  });\n  return contents;\n};\n\nconst dotProductAgentInfo: AgentFunctionInfo = {\n  name: \"dotProductAgent\",\n  agent: dotProductAgent,\n  mock: dotProductAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      matrix: {\n        type: \"array\",\n        description: \"two dimentional matrix\",\n        items: {\n          type: \"array\",\n          items: {\n            type: \"number\",\n          },\n        },\n      },\n      vector: {\n        type: \"array\",\n        description: \"the vector\",\n        items: {\n          type: \"number\",\n        },\n      },\n    },\n    required: [\"matrix\", \"vector\"],\n  },\n  output: {\n    type: \"array\",\n  },\n  samples: [\n    {\n      inputs: {\n        matrix: [\n          [1, 2],\n          [3, 4],\n          [5, 6],\n        ],\n        vector: [3, 2],\n      },\n      params: {},\n      result: [7, 17, 27],\n    },\n    {\n      inputs: {\n        matrix: [\n          [1, 2],\n          [2, 3],\n        ],\n        vector: [1, 2],\n      },\n      params: {},\n      result: [5, 8],\n    },\n  ],\n  description: \"dotProduct Agent\",\n  category: [\"matrix\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default dotProductAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\n\n// This agent returned a sorted array of one array (A) based on another array (B).\n// The default sorting order is \"decendant\".\n//\n// Parameters:\n//  acendant: Specifies if the sorting order should be acendant. The default is \"false\" (decendant).\n// Inputs:\n//  array: Array<any>; // array to be sorted\n//  values: Array<number>; // array of numbers for sorting\n//\nexport const sortByValuesAgent: AgentFunction<\n  {\n    assendant?: boolean;\n  },\n  Array<unknown>,\n  null,\n  {\n    array: Array<unknown>;\n    values: Array<unknown>;\n  }\n> = async ({ params, namedInputs }) => {\n  assert(!!namedInputs, \"sortByValue: namedInputs is UNDEFINED!\");\n  assert(!!namedInputs.array, \"sortByValue: namedInputs.array is UNDEFINED!\");\n  assert(!!namedInputs.values, \"sortByValue: namedInputs.values is UNDEFINED!\");\n\n  const direction = (params?.assendant ?? false) ? -1 : 1;\n  const array: Array<any> = namedInputs.array;\n  const values: Array<any> = namedInputs.values;\n  const joined = array.map((item, index) => {\n    return { item, value: values[index] };\n  });\n  const contents = joined\n    .sort((a, b) => {\n      return (b.value - a.value) * direction;\n    })\n    .map((a) => {\n      return a.item;\n    });\n  return contents;\n};\n\nconst sortByValuesAgentInfo: AgentFunctionInfo = {\n  name: \"sortByValuesAgent\",\n  agent: sortByValuesAgent,\n  mock: sortByValuesAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the array to sort\",\n      },\n      values: {\n        type: \"array\",\n        description: \"values associated with items in the array\",\n      },\n    },\n    required: [\"array\", \"values\"],\n  },\n  output: {\n    type: \"array\",\n  },\n  samples: [\n    {\n      inputs: {\n        array: [\"banana\", \"orange\", \"lemon\", \"apple\"],\n        values: [2, 5, 6, 4],\n      },\n      params: {},\n      result: [\"lemon\", \"orange\", \"apple\", \"banana\"],\n    },\n    {\n      inputs: {\n        array: [\"banana\", \"orange\", \"lemon\", \"apple\"],\n        values: [2, 5, 6, 4],\n      },\n      params: {\n        assendant: true,\n      },\n      result: [\"banana\", \"apple\", \"orange\", \"lemon\"],\n    },\n  ],\n  description: \"sortByValues Agent\",\n  category: [\"matrix\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default sortByValuesAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\nexport const echoAgent: AgentFunction = async ({ params, filterParams }) => {\n  if (params.filterParams) {\n    return filterParams;\n  }\n  return params;\n};\n\n// for test and document\nconst echoAgentInfo: AgentFunctionInfo = {\n  name: \"echoAgent\",\n  agent: echoAgent,\n  mock: echoAgent,\n  samples: [\n    {\n      inputs: {},\n      params: { text: \"this is test\" },\n      result: { text: \"this is test\" },\n    },\n    {\n      inputs: {},\n      params: {\n        text: \"If you add filterParams option, it will respond to filterParams\",\n        filterParams: true,\n      },\n      result: {},\n    },\n  ],\n  description: \"Echo agent\",\n  category: [\"test\"],\n  author: \"Satoshi Nakajima\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\n\nexport default echoAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\nexport const countingAgent: AgentFunction<{ count: number }, { list: number[] }> = async ({ params }) => {\n  return {\n    list: new Array(params.count).fill(undefined).map((_, i) => {\n      return i;\n    }),\n  };\n};\n\n// for test and document\nconst countingAgentInfo: AgentFunctionInfo = {\n  name: \"countingAgent\",\n  agent: countingAgent,\n  mock: countingAgent,\n  samples: [\n    {\n      inputs: {},\n      params: { count: 4 },\n      result: { list: [0, 1, 2, 3] },\n    },\n  ],\n  description: \"Counting agent\",\n  category: [\"test\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\n\nexport default countingAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\nexport const copyMessageAgent: AgentFunction<{ count: number; message: string }, { messages: string[] }> = async ({ params }) => {\n  return {\n    messages: new Array(params.count).fill(undefined).map(() => {\n      return params.message;\n    }),\n  };\n};\n\n// for test and document\nconst copyMessageAgentInfo: AgentFunctionInfo = {\n  name: \"copyMessageAgent\",\n  agent: copyMessageAgent,\n  mock: copyMessageAgent,\n  samples: [\n    {\n      inputs: {},\n      params: { count: 4, message: \"hello\" },\n      result: { messages: [\"hello\", \"hello\", \"hello\", \"hello\"] },\n    },\n  ],\n  description: \"CopyMessage agent\",\n  category: [\"test\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\n\nexport default copyMessageAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\nimport { isNamedInputs } from \"@graphai/agent_utils\";\n\nexport const copy2ArrayAgent: AgentFunction<{ count: number }> = async ({ inputs, namedInputs, params }) => {\n  const input = isNamedInputs(namedInputs) ? (namedInputs.item ? namedInputs.item : namedInputs) : inputs[0];\n  return new Array(params.count).fill(undefined).map(() => {\n    return input;\n  });\n};\n\n// for test and document\nconst copy2ArrayAgentInfo: AgentFunctionInfo = {\n  name: \"copy2ArrayAgent\",\n  agent: copy2ArrayAgent,\n  mock: copy2ArrayAgent,\n  samples: [\n    {\n      inputs: { item: { message: \"hello\" } },\n      params: { count: 10 },\n      result: [\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n      ],\n    },\n    {\n      inputs: { message: \"hello\" },\n      params: { count: 10 },\n      result: [\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n        { message: \"hello\" },\n      ],\n    },\n    {\n      inputs: { item: \"hello\" },\n      params: { count: 10 },\n      result: [\"hello\", \"hello\", \"hello\", \"hello\", \"hello\", \"hello\", \"hello\", \"hello\", \"hello\", \"hello\"],\n    },\n  ],\n  description: \"Copy2Array agent\",\n  category: [\"test\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\n\nexport default copy2ArrayAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\nimport { isNamedInputs } from \"@graphai/agent_utils\";\n\nexport const mergeNodeIdAgent: AgentFunction<null, Record<string, unknown>, Record<string, unknown>, { array: Record<string, unknown>[] }> = async ({\n  debugInfo: { nodeId },\n  inputs,\n  namedInputs,\n}) => {\n  // console.log(\"executing\", nodeId);\n  const dataSet = isNamedInputs(namedInputs) ? namedInputs.array : inputs;\n\n  return dataSet.reduce(\n    (tmp, input) => {\n      return { ...tmp, ...input };\n    },\n    { [nodeId]: \"hello\" },\n  );\n};\n\n// for test and document\nconst mergeNodeIdAgentInfo: AgentFunctionInfo = {\n  name: \"mergeNodeIdAgent\",\n  agent: mergeNodeIdAgent,\n  mock: mergeNodeIdAgent,\n  samples: [\n    {\n      inputs: { array: [{ message: \"hello\" }] },\n      params: {},\n      result: {\n        message: \"hello\",\n        test: \"hello\",\n      },\n    },\n  ],\n  description: \"merge node id agent\",\n  category: [\"test\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\n\nexport default mergeNodeIdAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, sleep } from \"graphai\";\n\nexport const streamMockAgent: AgentFunction = async ({ params, filterParams, namedInputs }) => {\n  const message = params.message ?? namedInputs.message ?? \"\";\n\n  for await (const token of message.split(\"\")) {\n    if (filterParams.streamTokenCallback) {\n      filterParams.streamTokenCallback(token);\n    }\n    await sleep(params.sleep || 100);\n  }\n\n  return { message };\n};\n\n// for test and document\nconst streamMockAgentInfo: AgentFunctionInfo = {\n  name: \"streamMockAgent\",\n  agent: streamMockAgent,\n  mock: streamMockAgent,\n  inputs: {\n    anyOf: [\n      {\n        type: \"object\",\n        properties: {\n          message: {\n            type: \"string\",\n            description: \"streaming message\",\n          },\n        },\n      },\n      {\n        type: \"array\",\n      },\n    ],\n  },\n  samples: [\n    {\n      inputs: {},\n      params: { message: \"this is params test\" },\n      result: { message: \"this is params test\" },\n    },\n    {\n      inputs: { message: \"this is named inputs test\" },\n      params: {},\n      result: { message: \"this is named inputs test\" },\n    },\n  ],\n  description: \"Stream mock agent\",\n  category: [\"test\"],\n  author: \"Isamu Arimoto\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n  stream: true,\n};\n\nexport default streamMockAgentInfo;\n","import { GraphAI, AgentFunction, AgentFunctionInfo, StaticNodeData, assert, graphDataLatestVersion } from \"graphai\";\n\nexport const nestedAgent: AgentFunction<{ throwError?: boolean }> = async ({\n  namedInputs,\n  log,\n  debugInfo,\n  onLogCallback,\n  params,\n  forNestedGraph,\n}) => {\n  assert(!!forNestedGraph, \"update graphai\")\n\n  const {\n    agents,\n    graphData,\n    graphOptions\n  } = forNestedGraph;\n  const {\n    taskManager,\n  } = graphOptions;\n  const throwError = params.throwError ?? false;\n  if (taskManager) {\n    const status = taskManager.getStatus(false);\n    assert(status.concurrency > status.running, `nestedAgent: Concurrency is too low: ${status.concurrency}`);\n  }\n  assert(!!graphData, \"nestedAgent: graph is required\");\n\n  const { nodes } = graphData;\n  const nestedGraphData = { ...graphData, nodes: { ...nodes }, version: graphDataLatestVersion }; // deep enough copy\n\n  const nodeIds = Object.keys(namedInputs);\n  if (nodeIds.length > 0) {\n    nodeIds.forEach((nodeId) => {\n      if (nestedGraphData.nodes[nodeId] === undefined) {\n        // If the input node does not exist, automatically create a static node\n        nestedGraphData.nodes[nodeId] = { value: namedInputs[nodeId] };\n      } else {\n        // Otherwise, inject the proper data here (instead of calling injectTo method later)\n        (nestedGraphData.nodes[nodeId] as StaticNodeData)[\"value\"] = namedInputs[nodeId];\n      }\n    });\n  }\n\n  try {\n    if (nestedGraphData.version === undefined && debugInfo.version) {\n      nestedGraphData.version = debugInfo.version;\n    }\n    const graphAI = new GraphAI(nestedGraphData, agents || {}, graphOptions);\n    // for backward compatibility. Remove 'if' later\n    if (onLogCallback) {\n      graphAI.onLogCallback = onLogCallback;\n    }\n\n    const results = await graphAI.run(false);\n    log?.push(...graphAI.transactionLogs());\n    return results;\n  } catch (error) {\n    if (error instanceof Error && !throwError) {\n      return {\n        onError: {\n          message: error.message,\n          error,\n        },\n      };\n    }\n    throw error;\n  }\n};\n\nconst nestedAgentInfo: AgentFunctionInfo = {\n  name: \"nestedAgent\",\n  agent: nestedAgent,\n  mock: nestedAgent,\n  samples: [\n    {\n      inputs: {\n        message: \"hello\",\n      },\n      params: {},\n      result: {\n        test: [\"hello\"],\n      },\n      graph: {\n        nodes: {\n          test: {\n            agent: \"copyAgent\",\n            params: { namedKey: \"messages\" },\n            inputs: { messages: [\":message\"] },\n            isResult: true,\n          },\n        },\n      },\n    },\n  ],\n  description: \"nested Agent\",\n  category: [\"graph\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default nestedAgentInfo;\n","import { GraphAI, AgentFunction, AgentFunctionInfo, StaticNodeData, assert, graphDataLatestVersion } from \"graphai\";\n\nexport const mapAgent: AgentFunction<\n  {\n    limit?: number;\n    resultAll?: boolean;\n    compositeResult?: boolean;\n    throwError?: boolean;\n  },\n  Record<string, any>,\n  any\n> = async ({ params, namedInputs, log, debugInfo, forNestedGraph, onLogCallback }) => {\n  assert(!!forNestedGraph, \"update graphai\")\n\n  const {\n    agents,\n    graphData,\n    graphOptions\n  } = forNestedGraph;\n  const { taskManager } = graphOptions;\n  \n  if (taskManager) {\n    const status = taskManager.getStatus();\n    assert(status.concurrency > status.running, `mapAgent: Concurrency is too low: ${status.concurrency}`);\n  }\n\n  assert(!!namedInputs.rows, \"mapAgent: rows property is required in namedInput\");\n  assert(!!graphData, \"mapAgent: graph is required\");\n\n  const rows = namedInputs.rows.map((item: any) => item);\n  if (params.limit && params.limit < rows.length) {\n    rows.length = params.limit; // trim\n  }\n  const resultAll = params.resultAll ?? false;\n  const throwError = params.throwError ?? false;\n\n  const { nodes } = graphData;\n  const nestedGraphData = { ...graphData, nodes: { ...nodes }, version: graphDataLatestVersion }; // deep enough copy\n\n  const nodeIds = Object.keys(namedInputs);\n  nodeIds.forEach((nodeId) => {\n    const mappedNodeId = nodeId === \"rows\" ? \"row\" : nodeId;\n    if (nestedGraphData.nodes[mappedNodeId] === undefined) {\n      // If the input node does not exist, automatically create a static node\n      nestedGraphData.nodes[mappedNodeId] = { value: namedInputs[nodeId] };\n    } else {\n      // Otherwise, inject the proper data here (instead of calling injectTo method later)\n      (nestedGraphData.nodes[mappedNodeId] as StaticNodeData)[\"value\"] = namedInputs[nodeId];\n    }\n  });\n\n  try {\n    if (nestedGraphData.version === undefined && debugInfo.version) {\n      nestedGraphData.version = debugInfo.version;\n    }\n    const graphs: Array<GraphAI> = rows.map((row: any) => {\n      const graphAI = new GraphAI(nestedGraphData, agents || {}, graphOptions);\n      graphAI.injectValue(\"row\", row, \"__mapAgent_inputs__\");\n      // for backward compatibility. Remove 'if' later\n      if (onLogCallback) {\n        graphAI.onLogCallback = onLogCallback;\n      }\n      return graphAI;\n    });\n\n    const runs = graphs.map((graph) => {\n      return graph.run(resultAll);\n    });\n    const results = await Promise.all(runs);\n    const nodeIds = Object.keys(results[0]);\n    // assert(nodeIds.length > 0, \"mapAgent: no return values (missing isResult)\");\n\n    if (log) {\n      const logs = graphs.map((graph, index) => {\n        return graph.transactionLogs().map((log) => {\n          log.mapIndex = index;\n          return log;\n        });\n      });\n      log.push(...logs.flat());\n    }\n\n    if (params.compositeResult) {\n      const compositeResult = nodeIds.reduce((tmp: Record<string, Array<any>>, nodeId) => {\n        tmp[nodeId] = results.map((result) => {\n          return result[nodeId];\n        });\n        return tmp;\n      }, {});\n      return compositeResult;\n    }\n    return results;\n  } catch (error) {\n    if (error instanceof Error && !throwError) {\n      return {\n        onError: {\n          message: error.message,\n          error,\n        },\n      };\n    }\n    throw error;\n  }\n};\n\nconst mapAgentInfo: AgentFunctionInfo = {\n  name: \"mapAgent\",\n  agent: mapAgent,\n  mock: mapAgent,\n  samples: [\n    {\n      inputs: {\n        rows: [1, 2],\n      },\n      params: {},\n      result: [{ test: [1] }, { test: [2] }],\n      graph: {\n        nodes: {\n          test: {\n            agent: \"copyAgent\",\n            params: { namedKey: \"rows\" },\n            inputs: { rows: [\":row\"] },\n            isResult: true,\n          },\n        },\n      },\n    },\n    {\n      inputs: {\n        rows: [\"apple\", \"orange\", \"banana\", \"lemon\", \"melon\", \"pineapple\", \"tomato\"],\n      },\n      params: {},\n      graph: {\n        nodes: {\n          node2: {\n            agent: \"stringTemplateAgent\",\n            params: {\n              template: \"I love ${word}.\",\n            },\n            inputs: { word: \":row\" },\n            isResult: true,\n          },\n        },\n      },\n      result: [\n        { node2: \"I love apple.\" },\n        { node2: \"I love orange.\" },\n        { node2: \"I love banana.\" },\n        { node2: \"I love lemon.\" },\n        { node2: \"I love melon.\" },\n        { node2: \"I love pineapple.\" },\n        { node2: \"I love tomato.\" },\n      ],\n    },\n    {\n      inputs: {\n        rows: [{ fruit: \"apple\" }, { fruit: \"orange\" }],\n      },\n      params: {},\n      graph: {\n        nodes: {\n          node2: {\n            agent: \"stringTemplateAgent\",\n            params: {\n              template: \"I love ${item}.\",\n            },\n            inputs: { item: \":row.fruit\" },\n            isResult: true,\n          },\n        },\n      },\n      result: [{ node2: \"I love apple.\" }, { node2: \"I love orange.\" }],\n    },\n    {\n      inputs: {\n        rows: [{ fruit: \"apple\" }, { fruit: \"orange\" }],\n        name: \"You\",\n        verb: \"like\",\n      },\n      params: {},\n      graph: {\n        nodes: {\n          node2: {\n            agent: \"stringTemplateAgent\",\n            params: {\n              template: \"${name} ${verb} ${fruit}.\",\n            },\n            inputs: { fruit: \":row.fruit\", name: \":name\", verb: \":verb\" },\n            isResult: true,\n          },\n        },\n      },\n      result: [{ node2: \"You like apple.\" }, { node2: \"You like orange.\" }],\n    },\n    {\n      inputs: {\n        rows: [1, 2],\n      },\n      params: {\n        resultAll: true,\n      },\n      result: [\n        {\n          test: [1],\n          row: 1,\n        },\n        {\n          test: [2],\n          row: 2,\n        },\n      ],\n      graph: {\n        nodes: {\n          test: {\n            agent: \"copyAgent\",\n            params: { namedKey: \"rows\" },\n            inputs: { rows: [\":row\"] },\n          },\n        },\n      },\n    },\n    {\n      inputs: {\n        rows: [1, 2],\n      },\n      params: {\n        resultAll: true,\n      },\n      result: [\n        {\n          map: [\n            {\n              test: 1,\n            },\n            {\n              test: 1,\n            },\n          ],\n          row: 1,\n          test: 1,\n        },\n        {\n          map: [\n            {\n              test: 2,\n            },\n            {\n              test: 2,\n            },\n          ],\n          test: 2,\n          row: 2,\n        },\n      ],\n      graph: {\n        nodes: {\n          test: {\n            agent: \"copyAgent\",\n            params: { namedKey: \"row\" },\n            inputs: { row: \":row\" },\n          },\n          map: {\n            agent: \"mapAgent\",\n            inputs: { rows: [\":test\", \":test\"] },\n            graph: {\n              nodes: {\n                test: {\n                  isResult: true,\n                  agent: \"copyAgent\",\n                  params: { namedKey: \"row\" },\n                  inputs: { row: \":row\" },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n\n    // old response\n    {\n      inputs: {\n        rows: [1, 2],\n      },\n      params: {\n        compositeResult: true,\n      },\n      result: {\n        test: [[1], [2]],\n      },\n      graph: {\n        nodes: {\n          test: {\n            agent: \"copyAgent\",\n            params: { namedKey: \"rows\" },\n            inputs: { rows: [\":row\"] },\n            isResult: true,\n          },\n        },\n      },\n    },\n    {\n      inputs: {\n        rows: [\"apple\", \"orange\", \"banana\", \"lemon\", \"melon\", \"pineapple\", \"tomato\"],\n      },\n      params: {\n        compositeResult: true,\n      },\n      graph: {\n        nodes: {\n          node2: {\n            agent: \"stringTemplateAgent\",\n            params: {\n              template: \"I love ${row}.\",\n            },\n            inputs: { row: \":row\" },\n            isResult: true,\n          },\n        },\n      },\n      result: {\n        node2: [\"I love apple.\", \"I love orange.\", \"I love banana.\", \"I love lemon.\", \"I love melon.\", \"I love pineapple.\", \"I love tomato.\"],\n      },\n    },\n    {\n      inputs: {\n        rows: [1, 2],\n      },\n      params: {\n        resultAll: true,\n        compositeResult: true,\n      },\n      result: {\n        test: [[1], [2]],\n        row: [1, 2],\n      },\n      graph: {\n        nodes: {\n          test: {\n            agent: \"copyAgent\",\n            params: { namedKey: \"rows\" },\n            inputs: { rows: [\":row\"] },\n          },\n        },\n      },\n    },\n    {\n      inputs: {\n        rows: [1, 2],\n      },\n      params: {\n        resultAll: true,\n        compositeResult: true,\n      },\n      result: {\n        test: [[1], [2]],\n        map: [\n          {\n            test: [[[1]], [[1]]],\n          },\n          {\n            test: [[[2]], [[2]]],\n          },\n        ],\n        row: [1, 2],\n      },\n      graph: {\n        nodes: {\n          test: {\n            agent: \"copyAgent\",\n            params: { namedKey: \"rows\" },\n            inputs: { rows: [\":row\"] },\n          },\n          map: {\n            agent: \"mapAgent\",\n            inputs: { rows: [\":test\", \":test\"] },\n            params: {\n              compositeResult: true,\n            },\n            graph: {\n              nodes: {\n                test: {\n                  isResult: true,\n                  agent: \"copyAgent\",\n                  params: { namedKey: \"rows\" },\n                  inputs: { rows: [\":row\"] },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  ],\n  description: \"Map Agent\",\n  category: [\"graph\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default mapAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\nimport { isNamedInputs } from \"@graphai/agent_utils\";\n\nexport const totalAgent: AgentFunction<Record<never, never>, Record<string, number>, null, { array: Record<string, number>[] }> = async ({ namedInputs }) => {\n  assert(isNamedInputs(namedInputs), \"totalAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }\");\n  assert(!!namedInputs?.array, \"totalAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }\");\n\n  return namedInputs.array.reduce((result, input) => {\n    const inputArray = Array.isArray(input) ? input : [input];\n    inputArray.forEach((innerInput) => {\n      Object.keys(innerInput).forEach((key) => {\n        const value = innerInput[key];\n        if (result[key]) {\n          result[key] += value;\n        } else {\n          result[key] = value;\n        }\n      });\n    });\n    return result;\n  }, {});\n};\n\n//\nconst totalAgentInfo: AgentFunctionInfo = {\n  name: \"totalAgent\",\n  agent: totalAgent,\n  mock: totalAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the array\",\n      },\n    },\n    required: [\"array\"],\n  },\n  output: {\n    type: \"object\",\n  },\n  samples: [\n    {\n      inputs: { array: [{ a: 1 }, { a: 2 }, { a: 3 }] },\n      params: {},\n      result: { a: 6 },\n    },\n    {\n      inputs: { array: [[{ a: 1, b: -1 }, { c: 10 }], [{ a: 2, b: -1 }], [{ a: 3, b: -2 }, { d: -10 }]] },\n      params: {},\n      result: { a: 6, b: -4, c: 10, d: -10 },\n    },\n    {\n      inputs: { array: [{ a: 1 }] },\n      params: {},\n      result: { a: 1 },\n    },\n    {\n      inputs: { array: [{ a: 1 }, { a: 2 }] },\n      params: {},\n      result: { a: 3 },\n    },\n    {\n      inputs: { array: [{ a: 1 }, { a: 2 }, { a: 3 }] },\n      params: {},\n      result: { a: 6 },\n    },\n    {\n      inputs: {\n        array: [\n          { a: 1, b: 1 },\n          { a: 2, b: 2 },\n          { a: 3, b: 0 },\n        ],\n      },\n      params: {},\n      result: { a: 6, b: 3 },\n    },\n    {\n      inputs: { array: [{ a: 1 }, { a: 2, b: 2 }, { a: 3, b: 0 }] },\n      params: {},\n      result: { a: 6, b: 2 },\n    },\n  ],\n  description: \"Returns the sum of input values\",\n  category: [\"data\"],\n  author: \"Satoshi Nakajima\",\n  repository: \"https://github.com/snakajima/graphai\",\n  license: \"MIT\",\n};\nexport default totalAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\nimport { isNamedInputs } from \"@graphai/agent_utils\";\n\nexport const dataSumTemplateAgent: AgentFunction<null, number, null, { array: number[] }> = async ({ namedInputs }) => {\n  assert(isNamedInputs(namedInputs), \"dataSumTemplateAgent: namedInputs is UNDEFINED! Set inputs: { array: :arrayNodeId }\");\n  assert(!!namedInputs?.array, \"dataSumTemplateAgent: namedInputs.array is UNDEFINED! Set inputs: { array: :arrayNodeId }\");\n\n  return namedInputs.array.reduce((tmp, input) => {\n    return tmp + input;\n  }, 0);\n};\n\nconst dataSumTemplateAgentInfo: AgentFunctionInfo = {\n  name: \"dataSumTemplateAgent\",\n  agent: dataSumTemplateAgent,\n  mock: dataSumTemplateAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the array of numbers to calculate the sum of\",\n        items: {\n          type: \"integer\",\n        },\n      },\n    },\n    required: [\"array\"],\n  },\n  output: {\n    type: \"number\",\n  },\n  samples: [\n    {\n      inputs: { array: [1] },\n      params: {},\n      result: 1,\n    },\n    {\n      inputs: { array: [1, 2] },\n      params: {},\n      result: 3,\n    },\n    {\n      inputs: { array: [1, 2, 3] },\n      params: {},\n      result: 6,\n    },\n  ],\n  description: \"Returns the sum of input values\",\n  category: [\"data\"],\n  author: \"Satoshi Nakajima\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default dataSumTemplateAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\nconst applyFilter = (\n  object: any,\n  index: number,\n  arrayInputs: any,\n  include: Array<string> | undefined,\n  exclude: Array<string> | undefined,\n  alter: Record<string, Record<string, string>> | undefined,\n  inject: Array<Record<string, any>> | undefined,\n  swap: Record<string, string> | undefined,\n  inspect: Array<Record<string, any>> | undefined,\n) => {\n  const propIds = include ? include : Object.keys(object);\n  const excludeSet = new Set(exclude ?? []);\n  const result = propIds.reduce((tmp: Record<string, any>, propId) => {\n    if (!excludeSet.has(propId)) {\n      const mapping = alter && alter[propId];\n      if (mapping && mapping[object[propId]]) {\n        tmp[propId] = mapping[object[propId]];\n      } else {\n        tmp[propId] = object[propId];\n      }\n    }\n    return tmp;\n  }, {});\n\n  if (inject) {\n    inject.forEach((item) => {\n      if (item.index === undefined || item.index === index) {\n        result[item.propId] = arrayInputs[item.from];\n      }\n    });\n  }\n  if (inspect) {\n    inspect.forEach((item) => {\n      const value = arrayInputs[item.from ?? 1]; // default is arrayInputs[1]\n      if (item.equal) {\n        result[item.propId] = item.equal === value;\n      } else if (item.notEqual) {\n        result[item.propId] = item.notEqual !== value;\n      }\n    });\n  }\n  if (swap) {\n    Object.keys(swap).forEach((key) => {\n      const tmp = result[key];\n      result[key] = result[swap[key]];\n      result[swap[key]] = tmp;\n    });\n  }\n  return result;\n};\n\nexport const propertyFilterAgent: AgentFunction<{\n  include?: Array<string>;\n  exclude?: Array<string>;\n  alter?: Record<string, Record<string, string>>;\n  inject?: Array<Record<string, any>>;\n  inspect?: Array<Record<string, any>>;\n  swap?: Record<string, string>;\n}> = async ({ namedInputs, params }) => {\n  const { include, exclude, alter, inject, swap, inspect } = params;\n  const { array, item } = namedInputs;\n  if (array) {\n    // This is advanced usage, including \"inject\" and \"inspect\", which uses\n    // array[1], array[2], ...\n    const [target] = array; // Extract the first one\n    if (Array.isArray(target)) {\n      return target.map((item, index) => applyFilter(item, index, array, include, exclude, alter, inject, swap, inspect));\n    }\n    return applyFilter(target, 0, array, include, exclude, alter, inject, swap, inspect);\n  } else if (item) {\n    return applyFilter(item, 0, [], include, exclude, alter, inject, swap, inspect);\n  }\n  return false;\n};\n\nconst testInputs = {\n  array: [\n    [\n      { color: \"red\", model: \"Model 3\", type: \"EV\", maker: \"Tesla\", range: 300 },\n      { color: \"blue\", model: \"Model Y\", type: \"EV\", maker: \"Tesla\", range: 400 },\n    ],\n    \"Tesla Motors\",\n  ],\n};\n\nconst propertyFilterAgentInfo: AgentFunctionInfo = {\n  name: \"propertyFilterAgent\",\n  agent: propertyFilterAgent,\n  mock: propertyFilterAgent,\n  inputs: {\n    type: \"object\",\n  },\n  output: {\n    type: \"any\",\n    properties: {\n      array: {\n        type: \"array\",\n        description: \"the array to apply filter\",\n      },\n      item: {\n        type: \"object\",\n        description: \"the object to apply filter\",\n      },\n    },\n  },\n  samples: [\n    {\n      inputs: { array: [testInputs.array[0][0]] },\n      params: { include: [\"color\", \"model\"] },\n      result: { color: \"red\", model: \"Model 3\" },\n    },\n    {\n      inputs: { item: testInputs.array[0][0] },\n      params: { include: [\"color\", \"model\"] },\n      result: { color: \"red\", model: \"Model 3\" },\n    },\n    {\n      inputs: testInputs,\n      params: { include: [\"color\", \"model\"] },\n      result: [\n        { color: \"red\", model: \"Model 3\" },\n        { color: \"blue\", model: \"Model Y\" },\n      ],\n    },\n    {\n      inputs: testInputs,\n      params: { exclude: [\"color\", \"model\"] },\n      result: [\n        { type: \"EV\", maker: \"Tesla\", range: 300 },\n        { type: \"EV\", maker: \"Tesla\", range: 400 },\n      ],\n    },\n    {\n      inputs: { item: testInputs.array[0][0] },\n      params: { exclude: [\"color\", \"model\"] },\n      result: { type: \"EV\", maker: \"Tesla\", range: 300 },\n    },\n    {\n      inputs: testInputs,\n      params: { alter: { color: { red: \"blue\", blue: \"red\" } } },\n      result: [\n        {\n          color: \"blue\",\n          model: \"Model 3\",\n          type: \"EV\",\n          maker: \"Tesla\",\n          range: 300,\n        },\n        {\n          color: \"red\",\n          model: \"Model Y\",\n          type: \"EV\",\n          maker: \"Tesla\",\n          range: 400,\n        },\n      ],\n    },\n    {\n      inputs: { item: testInputs.array[0][0] },\n      params: { alter: { color: { red: \"blue\", blue: \"red\" } } },\n      result: {\n        color: \"blue\",\n        model: \"Model 3\",\n        type: \"EV\",\n        maker: \"Tesla\",\n        range: 300,\n      },\n    },\n    {\n      inputs: testInputs,\n      params: { swap: { maker: \"model\" } },\n      result: [\n        {\n          color: \"red\",\n          model: \"Tesla\",\n          type: \"EV\",\n          maker: \"Model 3\",\n          range: 300,\n        },\n        {\n          color: \"blue\",\n          model: \"Tesla\",\n          type: \"EV\",\n          maker: \"Model Y\",\n          range: 400,\n        },\n      ],\n    },\n    {\n      inputs: { item: testInputs.array[0][0] },\n      params: { swap: { maker: \"model\" } },\n      result: {\n        color: \"red\",\n        model: \"Tesla\",\n        type: \"EV\",\n        maker: \"Model 3\",\n        range: 300,\n      },\n    },\n    {\n      inputs: testInputs,\n      params: { inject: [{ propId: \"maker\", from: 1 }] },\n      result: [\n        {\n          color: \"red\",\n          model: \"Model 3\",\n          type: \"EV\",\n          maker: \"Tesla Motors\",\n          range: 300,\n        },\n        {\n          color: \"blue\",\n          model: \"Model Y\",\n          type: \"EV\",\n          maker: \"Tesla Motors\",\n          range: 400,\n        },\n      ],\n    },\n    {\n      inputs: testInputs,\n      params: { inject: [{ propId: \"maker\", from: 1, index: 0 }] },\n      result: [\n        {\n          color: \"red\",\n          model: \"Model 3\",\n          type: \"EV\",\n          maker: \"Tesla Motors\",\n          range: 300,\n        },\n        {\n          color: \"blue\",\n          model: \"Model Y\",\n          type: \"EV\",\n          maker: \"Tesla\",\n          range: 400,\n        },\n      ],\n    },\n    {\n      inputs: testInputs,\n      params: {\n        inspect: [\n          { propId: \"isTesla\", equal: \"Tesla Motors\" }, // from: 1 is implied\n          { propId: \"isGM\", notEqual: \"Tesla Motors\", from: 1 },\n        ],\n      },\n      result: [\n        {\n          color: \"red\",\n          model: \"Model 3\",\n          type: \"EV\",\n          maker: \"Tesla\",\n          range: 300,\n          isTesla: true,\n          isGM: false,\n        },\n        {\n          color: \"blue\",\n          model: \"Model Y\",\n          type: \"EV\",\n          maker: \"Tesla\",\n          range: 400,\n          isTesla: true,\n          isGM: false,\n        },\n      ],\n    },\n  ],\n  description: \"Filter properties based on property name either with 'include', 'exclude', 'alter', 'swap', 'inject', 'inspect'\",\n  category: [\"data\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default propertyFilterAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, assert } from \"graphai\";\nimport { isNamedInputs } from \"@graphai/agent_utils\";\n\nexport const copyAgent: AgentFunction<{\n  namedKey?: string;\n}> = async ({ namedInputs, params }) => {\n  const { namedKey } = params;\n  assert(isNamedInputs(namedInputs), \"copyAgent: namedInputs is UNDEFINED!\");\n  if (namedKey) {\n    return namedInputs[namedKey];\n  }\n  return namedInputs;\n};\n\nconst copyAgentInfo: AgentFunctionInfo = {\n  name: \"copyAgent\",\n  agent: copyAgent,\n  mock: copyAgent,\n  inputs: {\n    anyOf: [{ type: \"string\" }, { type: \"integer\" }, { type: \"object\" }, { type: \"array\" }],\n  },\n  output: {\n    anyOf: [{ type: \"string\" }, { type: \"integer\" }, { type: \"object\" }, { type: \"array\" }],\n  },\n  samples: [\n    {\n      inputs: { color: \"red\", model: \"Model 3\" },\n      params: {},\n      result: { color: \"red\", model: \"Model 3\" },\n    },\n    {\n      inputs: { array: [\"Hello World\", \"Discarded\"] },\n      params: {},\n      result: { array: [\"Hello World\", \"Discarded\"] },\n    },\n    {\n      inputs: { color: \"red\", model: \"Model 3\" },\n      params: { namedKey: \"color\" },\n      result: \"red\",\n    },\n  ],\n  description: \"Returns namedInputs\",\n  category: [\"data\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default copyAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\nexport const vanillaFetchAgent: AgentFunction<{ debug?: boolean; type?: string; throwError?: boolean }, any, any> = async ({ namedInputs, params }) => {\n  const { url, method, queryParams, headers, body } = namedInputs;\n  const throwError = params.throwError ?? false;\n\n  const url0 = new URL(url);\n  const headers0 = headers ? { ...headers } : {};\n\n  if (queryParams) {\n    const params = new URLSearchParams(queryParams);\n    url0.search = params.toString();\n  }\n\n  if (body) {\n    headers0[\"Content-Type\"] = \"application/json\";\n  }\n\n  const fetchOptions: RequestInit = {\n    method: (method ?? body) ? \"POST\" : \"GET\",\n    headers: new Headers(headers0),\n    body: body ? JSON.stringify(body) : undefined,\n  };\n\n  if (params?.debug) {\n    return {\n      url: url0.toString(),\n      method: fetchOptions.method,\n      headers: headers0,\n      body: fetchOptions.body,\n    };\n  }\n\n  const response = await fetch(url0.toString(), fetchOptions);\n\n  if (!response.ok) {\n    const status = response.status;\n    const type = params?.type ?? \"json\";\n    const error = type === \"json\" ? await response.json() : await response.text();\n    if (throwError) {\n      throw new Error(`HTTP error: ${status}`);\n    }\n    return {\n      onError: {\n        message: `HTTP error: ${status}`,\n        status,\n        error,\n      },\n    };\n  }\n\n  const result = await (async () => {\n    const type = params?.type ?? \"json\";\n    if (type === \"json\") {\n      return await response.json();\n    } else if (type === \"text\") {\n      return response.text();\n    }\n    throw new Error(`Unknown Type! ${type}`);\n  })();\n\n  return result;\n};\n\nconst vanillaFetchAgentInfo: AgentFunctionInfo = {\n  name: \"vanillaFetchAgent\",\n  agent: vanillaFetchAgent,\n  mock: vanillaFetchAgent,\n  inputs: {\n    type: \"object\",\n    properties: {\n      url: {\n        type: \"string\",\n        description: \"baseurl\",\n      },\n      method: {\n        type: \"string\",\n        description: \"HTTP method\",\n      },\n      headers: {\n        type: \"object\",\n        description: \"HTTP headers\",\n      },\n      quaryParams: {\n        type: \"object\",\n        description: \"Query parameters\",\n      },\n      body: {\n        anyOf: [{ type: \"string\" }, { type: \"object\" }],\n        description: \"body\",\n      },\n    },\n    required: [\"url\"],\n  },\n  output: {\n    type: \"array\",\n  },\n  samples: [\n    {\n      inputs: { url: \"https://www.google.com\", queryParams: { foo: \"bar\" }, headers: { \"x-myHeader\": \"secret\" } },\n      params: {\n        debug: true,\n      },\n      result: {\n        method: \"GET\",\n        url: \"https://www.google.com/?foo=bar\",\n        headers: {\n          \"x-myHeader\": \"secret\",\n        },\n        body: undefined,\n      },\n    },\n    {\n      inputs: { url: \"https://www.google.com\", body: { foo: \"bar\" } },\n      params: {\n        debug: true,\n      },\n      result: {\n        method: \"POST\",\n        url: \"https://www.google.com/\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ foo: \"bar\" }),\n      },\n    },\n  ],\n  description: \"Retrieves JSON data from the specified URL\",\n  category: [\"service\"],\n  author: \"Receptron\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default vanillaFetchAgentInfo;\n","import { AgentFunction, AgentFunctionInfo, sleep } from \"graphai\";\n\nexport const sleeperAgent: AgentFunction<{ duration?: number }> = async ({ params, namedInputs }) => {\n  await sleep(params?.duration ?? 10);\n  return namedInputs;\n};\n\nconst sleeperAgentInfo: AgentFunctionInfo = {\n  name: \"sleeperAgent\",\n  agent: sleeperAgent,\n  mock: sleeperAgent,\n  samples: [\n    {\n      inputs: {},\n      params: { duration: 1 },\n      result: {},\n    },\n    {\n      inputs: [{ a: 1 }, { b: 2 }],\n      params: { duration: 1 },\n      result: {},\n    },\n    {\n      inputs: { array: [{ a: 1 }, { b: 2 }] },\n      params: { duration: 1 },\n      result: {\n        array: [{ a: 1 }, { b: 2 }],\n      },\n    },\n  ],\n  description: \"sleeper Agent\",\n  category: [\"sleeper\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default sleeperAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\ntype CompareDataItem = string | number | boolean | CompareData;\ntype CompareData = CompareDataItem[];\n\nconst compare = (_array: CompareData): boolean => {\n  if (_array.length !== 3) {\n    throw new Error(`compare inputs length must must be 3`);\n  }\n  const array = _array.map((value) => {\n    if (Array.isArray(value)) {\n      return compare(value);\n    }\n    return value;\n  });\n  const [a, operator, b] = array;\n  if (operator === \"==\") {\n    return a === b;\n  }\n  if (operator === \"!=\") {\n    return a !== b;\n  }\n  if (operator === \">\") {\n    return Number(a) > Number(b);\n  }\n  if (operator === \">=\") {\n    return Number(a) >= Number(b);\n  }\n  if (operator === \"<\") {\n    return Number(a) < Number(b);\n  }\n  if (operator === \"<=\") {\n    return Number(a) <= Number(b);\n  }\n  if (operator === \"||\") {\n    return !!a || !!b;\n  }\n  if (operator === \"&&\") {\n    return !!a && !!b;\n  }\n  if (operator === \"XOR\") {\n    return !!a === !b;\n  }\n  throw new Error(`unknown compare operator`);\n};\n\nexport const compareAgent: AgentFunction = async ({ namedInputs }) => {\n  return compare(namedInputs.array);\n};\n\nconst compareAgentInfo: AgentFunctionInfo = {\n  name: \"compareAgent\",\n  agent: compareAgent,\n  mock: compareAgent,\n  inputs: {},\n  output: {},\n  samples: [\n    {\n      inputs: { array: [\"abc\", \"==\", \"abc\"] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [\"abc\", \"==\", \"abcd\"] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [\"abc\", \"!=\", \"abc\"] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [\"abc\", \"!=\", \"abcd\"] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [\"10\", \">\", \"5\"] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [\"10\", \">\", \"15\"] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [10, \">\", 5] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [10, \">\", 15] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [\"10\", \">=\", \"5\"] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [\"10\", \">=\", \"10\"] },\n      params: {},\n      result: true,\n    },\n    {\n      // 10\n      inputs: { array: [\"10\", \">=\", \"19\"] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [10, \">=\", 5] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [10, \">=\", 10] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [10, \">=\", 19] },\n      params: {},\n      result: false,\n    },\n    //\n\n    {\n      inputs: { array: [\"10\", \"<\", \"5\"] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [\"10\", \"<\", \"15\"] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [10, \"<\", 5] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [10, \"<\", 15] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [\"10\", \"<=\", \"5\"] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [\"10\", \"<=\", \"10\"] },\n      params: {},\n      result: true,\n    },\n    {\n      // 20\n      inputs: { array: [\"10\", \"<=\", \"19\"] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [10, \"<=\", 5] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [10, \"<=\", 10] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [10, \"<=\", 19] },\n      params: {},\n      result: true,\n    },\n\n    {\n      inputs: { array: [true, \"||\", false] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [false, \"||\", false] },\n      params: {},\n      result: false,\n    },\n\n    {\n      inputs: { array: [true, \"&&\", false] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [true, \"&&\", true] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [true, \"XOR\", false] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [false, \"XOR\", true] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [false, \"XOR\", false] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [true, \"XOR\", true] },\n      params: {},\n      result: false,\n    },\n    //\n    {\n      inputs: { array: [[\"aaa\", \"==\", \"aaa\"], \"||\", [\"aaa\", \"==\", \"bbb\"]] },\n      params: {},\n      result: true,\n    },\n    {\n      inputs: { array: [[\"aaa\", \"==\", \"aaa\"], \"&&\", [\"aaa\", \"==\", \"bbb\"]] },\n      params: {},\n      result: false,\n    },\n    {\n      inputs: { array: [[[\"aaa\", \"==\", \"aaa\"], \"&&\", [\"bbb\", \"==\", \"bbb\"]], \"||\", [\"aaa\", \"&&\", \"bbb\"]] },\n      params: {},\n      result: true,\n    },\n  ],\n  description: \"compare\",\n  category: [\"compare\"],\n  author: \"Receptron\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default compareAgentInfo;\n","import { AgentFunction, AgentFunctionInfo } from \"graphai\";\n\n// Type for OpenAI's Embedding API\ninterface EmbeddingResponse {\n  object: string;\n  model: string;\n  usage: {\n    prompt_tokens: number;\n    total_tokens: number;\n  };\n  data: [\n    {\n      object: string;\n      index: number;\n      embedding: number[];\n    },\n  ];\n}\n\nconst defaultEmbeddingModel = \"text-embedding-3-small\";\nconst OpenAI_embedding_API = \"https://api.openai.com/v1/embeddings\";\n\n// This agent retrieves embedding vectors for an array of strings using OpenAI's API\n//\n// Parameters:\n//   model: Specifies the model (default is \"text-embedding-3-small\")\n// NamedInputs:\n//   array: Array<string>\n//   item: string,\n// Result:\n//   contents: Array<Array<number>>\n//\nexport const stringEmbeddingsAgent: AgentFunction<\n  {\n    model?: string;\n  },\n  number[][],\n  null,\n  { array: Array<string>; item: string }\n> = async ({ params, namedInputs }) => {\n  const { array, item } = namedInputs;\n\n  const sources = array ?? [item];\n  const apiKey = process.env.OPENAI_API_KEY;\n  if (!apiKey) {\n    throw new Error(\"OPENAI_API_KEY key is not set in environment variables.\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${apiKey}`,\n  };\n\n  const response = await fetch(OpenAI_embedding_API, {\n    method: \"POST\",\n    headers: headers,\n    body: JSON.stringify({\n      input: sources,\n      model: params?.model ?? defaultEmbeddingModel,\n    }),\n  });\n  const jsonResponse: EmbeddingResponse = await response.json();\n\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  const embeddings = jsonResponse.data.map((object) => {\n    return object.embedding;\n  });\n  return embeddings;\n};\n\nconst stringEmbeddingsAgentInfo: AgentFunctionInfo = {\n  name: \"stringEmbeddingsAgent\",\n  agent: stringEmbeddingsAgent,\n  mock: stringEmbeddingsAgent,\n  samples: [],\n  description: \"Embeddings Agent\",\n  category: [\"embedding\"],\n  author: \"Receptron team\",\n  repository: \"https://github.com/receptron/graphai\",\n  license: \"MIT\",\n};\nexport default stringEmbeddingsAgentInfo;\n"],"names":["stringSplitterAgent","async","params","namedInputs","assert","source","text","chunkSize","overlap","Math","floor","count","length","contents","Array","fill","undefined","map","_","i","startIndex","substring","stringSplitterAgentInfo","name","agent","mock","inputs","type","properties","description","required","output","samples","result","category","author","repository","license","processTemplate","template","match","input","replace","isArray","item","isObject","Object","keys","reduce","tmp","key","stringTemplateAgent","console","warn","index","sampleNamedInput","message1","message2","stringTemplateAgentInfo","apple","lemon","row","version","nodes","ai","isResult","prompt","jsonParserAgent","data","JSON","stringify","parse","sample_object","json_str","md_json1","join","md_json2","md_json3","jsonParserAgentInfo","anyOf","defineProperty","lib","value","isNamedInputs","sample2GraphData","sample","agentName","from","forEach","k","graph","pushAgent","items","array","push","pushAgentInfo","banana","popAgent","pop","popAgentInfo","array2","shiftAgent","shift","shiftAgentInfo","arrayFlatAgent","depth","flat","arrayFlatAgentInfo","arrayJoinAgent","separator","arrayJoinAgentInfo","dotProductAgent","matrix","vector","Error","vector0","dotProduct","dotProductAgentInfo","sortByValuesAgent","values","direction","assendant","sort","a","b","sortByValuesAgentInfo","echoAgent","filterParams","echoAgentInfo","countingAgent","list","countingAgentInfo","copyMessageAgent","messages","message","copyMessageAgentInfo","copy2ArrayAgent","copy2ArrayAgentInfo","mergeNodeIdAgent","debugInfo","nodeId","mergeNodeIdAgentInfo","test","streamMockAgent","token","split","streamTokenCallback","sleep","streamMockAgentInfo","stream","nestedAgent","log","onLogCallback","forNestedGraph","agents","graphData","graphOptions","taskManager","throwError","status","getStatus","concurrency","running","nestedGraphData","graphDataLatestVersion","nodeIds","graphAI","GraphAI","results","run","transactionLogs","error","onError","nestedAgentInfo","namedKey","mapAgent","rows","limit","resultAll","mappedNodeId","graphs","injectValue","runs","Promise","all","logs","mapIndex","compositeResult","mapAgentInfo","node2","word","fruit","verb","totalAgent","innerInput","totalAgentInfo","c","d","dataSumTemplateAgent","dataSumTemplateAgentInfo","applyFilter","object","arrayInputs","include","exclude","alter","inject","swap","inspect","propIds","excludeSet","Set","propId","has","mapping","equal","notEqual","propertyFilterAgent","target","testInputs","color","model","maker","range","propertyFilterAgentInfo","red","blue","isTesla","isGM","copyAgent","copyAgentInfo","vanillaFetchAgent","url","method","queryParams","headers","body","url0","URL","headers0","URLSearchParams","search","toString","fetchOptions","Headers","debug","response","fetch","ok","json","vanillaFetchAgentInfo","quaryParams","foo","sleeperAgent","duration","sleeperAgentInfo","compare","_array","operator","Number","compareAgent","compareAgentInfo","stringEmbeddingsAgent","sources","apiKey","process","env","OPENAI_API_KEY","Authorization","jsonResponse","embedding","stringEmbeddingsAgentInfo"],"mappings":"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"}