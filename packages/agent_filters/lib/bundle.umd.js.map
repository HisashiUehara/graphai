{"version":3,"file":"bundle.umd.js","sources":["../src/filters/stream.ts","../src/filters/namedinput_validator.ts","../src/filters/http_client.ts","../src/utils/runner.ts"],"sourcesContent":["import { AgentFilterFunction, AgentFunctionContext } from \"graphai\";\n\nexport const streamAgentFilterGenerator = <T>(callback: (context: AgentFunctionContext, data: T) => void) => {\n  const streamAgentFilter: AgentFilterFunction = async (context, next) => {\n    if (context.debugInfo.isResult) {\n      context.filterParams.streamTokenCallback = (data: T) => {\n        callback(context, data);\n      };\n    }\n    return next(context);\n  };\n  return streamAgentFilter;\n};\n","import { AgentFilterFunction } from \"graphai\";\nimport Ajv from \"ajv\";\n\n// export for test\nexport const agentInputValidator = (inputSchema: any, namedInputs: any) => {\n  const ajv = new Ajv();\n  const validateSchema = ajv.compile(inputSchema);\n  if (!validateSchema(namedInputs)) {\n    // console.log(validateSchema.errors);\n    throw new Error(\"schema not matched\");\n  }\n  return true;\n};\n\nexport const namedInputValidatorFilter: AgentFilterFunction = async (context, next) => {\n  const { inputSchema, namedInputs } = context;\n\n  if (inputSchema) {\n    if (inputSchema.type !== \"array\") {\n      agentInputValidator(inputSchema, namedInputs || {});\n    }\n  }\n\n  return next(context);\n};\n","import { AgentFilterFunction, AgentFunctionContext } from \"graphai\";\n\nasync function* streamChatCompletion(url: string, postData: AgentFunctionContext) {\n  const { params, inputs, namedInputs, debugInfo, filterParams } = postData;\n  const postBody = { params, inputs, debugInfo, filterParams, namedInputs };\n\n  const completion = await fetch(url, {\n    headers: {\n      \"Content-Type\": \"text/event-stream\",\n    },\n    method: \"POST\",\n    body: JSON.stringify(postBody),\n  });\n\n  const reader = completion.body?.getReader();\n\n  if (completion.status !== 200 || !reader) {\n    throw new Error(\"Request failed\");\n  }\n\n  const decoder = new TextDecoder(\"utf-8\");\n  let done = false;\n  while (!done) {\n    const { done: readDone, value } = await reader.read();\n    if (readDone) {\n      done = readDone;\n      reader.releaseLock();\n    } else {\n      const token = decoder.decode(value, { stream: true });\n      yield token;\n    }\n  }\n}\n\nconst streamingRequest = async (context: AgentFunctionContext, url: string, postData: AgentFunctionContext, isDebug: boolean | undefined) => {\n  const generator = streamChatCompletion(url, postData);\n\n  const messages = [];\n  for await (const token of generator) {\n    if (isDebug) {\n      console.log(token);\n    }\n    // callback to stream filter\n    if (token) {\n      messages.push(token);\n      if (messages.join(\"\").indexOf(\"___END___\") === -1 && context.filterParams.streamTokenCallback) {\n        context.filterParams.streamTokenCallback(token);\n      }\n    }\n  }\n\n  const payload_data = messages.join(\"\").split(\"___END___\")[1];\n  const data = JSON.parse(payload_data);\n  return data;\n};\nconst httpRequest = async (url: string, postData: AgentFunctionContext) => {\n  const response = await fetch(url, {\n    method: \"post\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(postData),\n  });\n  return await response.json();\n};\n\nexport const httpAgentFilter: AgentFilterFunction = async (context, next) => {\n  const { params, inputs, debugInfo, filterParams, namedInputs } = context;\n\n  if (filterParams?.server) {\n    const { baseUrl, isDebug, serverAgentUrlDictionary } = filterParams.server;\n    const agentId = debugInfo.agentId;\n    const isStreaming = filterParams.streamTokenCallback !== undefined;\n    const url = serverAgentUrlDictionary && agentId && serverAgentUrlDictionary[agentId] ? serverAgentUrlDictionary[agentId] : [baseUrl, agentId].join(\"/\");\n    if (url === undefined) {\n      console.log(\"httpAgentFilter: Url is not defined\");\n    }\n    const postData = {\n      params,\n      inputs,\n      debugInfo,\n      filterParams,\n      namedInputs,\n    };\n    if (isStreaming) {\n      return await streamingRequest(context, url, postData, isDebug);\n    }\n    return await httpRequest(url, postData);\n  }\n  return next(context);\n};\n","import { AgentFunctionContext, AgentFunction, AgentFilterInfo, ResultData } from \"graphai\";\n\n// for test and server.\nexport const agentFilterRunnerBuilder = (__agentFilters: AgentFilterInfo[]) => {\n  const agentFilters = __agentFilters;\n  const agentFilterRunner = (context: AgentFunctionContext, agent: AgentFunction) => {\n    let index = 0;\n\n    const next = (context: AgentFunctionContext): Promise<ResultData> => {\n      const agentFilter = agentFilters[index++];\n      if (agentFilter) {\n        return agentFilter.agent(context, next);\n      }\n      return agent(context);\n    };\n\n    return next(context);\n  };\n  return agentFilterRunner;\n};\n"],"names":["agentInputValidator","inputSchema","namedInputs","Ajv","compile","validateSchema","Error","streamingRequest","async","context","url","postData","isDebug","generator","params","inputs","debugInfo","filterParams","postBody","completion","fetch","headers","method","body","JSON","stringify","reader","getReader","status","decoder","TextDecoder","done","readDone","value","read","releaseLock","token","decode","stream","streamChatCompletion","messages","console","log","push","join","indexOf","streamTokenCallback","payload_data","split","parse","__agentFilters","agentFilters","agent","index","next","agentFilter","server","baseUrl","serverAgentUrlDictionary","agentId","isStreaming","undefined","response","json","httpRequest","type","callback","isResult","data"],"mappings":"0RAEa,MCEAA,EAAsB,CAACC,EAAkBC,KAGpD,KAFY,IAAIC,GACWC,QAAQH,EAC9BI,CAAeH,GAElB,MAAM,IAAII,MAAM,sBAElB,OAAO,CAAI,ECuBb,MAAMC,EAAmBC,MAAOC,EAA+BC,EAAaC,EAAgCC,KAC1G,MAAMC,EAjCRL,gBAAqCE,EAAaC,GAChD,MAAMG,OAAEA,EAAMC,OAAEA,EAAMb,YAAEA,EAAWc,UAAEA,EAASC,aAAEA,GAAiBN,EAC3DO,EAAW,CAAEJ,SAAQC,SAAQC,YAAWC,eAAcf,eAEtDiB,QAAmBC,MAAMV,EAAK,CAClCW,QAAS,CACP,eAAgB,qBAElBC,OAAQ,OACRC,KAAMC,KAAKC,UAAUP,KAGjBQ,EAASP,EAAWI,MAAMI,YAEhC,GAA0B,MAAtBR,EAAWS,SAAmBF,EAChC,MAAM,IAAIpB,MAAM,kBAGlB,MAAMuB,EAAU,IAAIC,YAAY,SAChC,IAAIC,GAAO,EACX,MAAQA,GAAM,CACZ,MAAQA,KAAMC,EAAQC,MAAEA,SAAgBP,EAAOQ,OAC/C,GAAIF,EACFD,EAAOC,EACPN,EAAOS,kBACF,CACL,MAAMC,EAAQP,EAAQQ,OAAOJ,EAAO,CAAEK,QAAQ,UACxCF,GAGZ,CAGoBG,CAAqB7B,EAAKC,GAEtC6B,EAAW,GACjB,UAAW,MAAMJ,KAASvB,EACpBD,GACF6B,QAAQC,IAAIN,GAGVA,IACFI,EAASG,KAAKP,IACkC,IAA5CI,EAASI,KAAK,IAAIC,QAAQ,cAAuBpC,EAAQQ,aAAa6B,qBACxErC,EAAQQ,aAAa6B,oBAAoBV,IAK/C,MAAMW,EAAeP,EAASI,KAAK,IAAII,MAAM,aAAa,GAE1D,OADaxB,KAAKyB,MAAMF,EACb,6BClD4BG,IACvC,MAAMC,EAAeD,EAcrB,MAb0B,CAACzC,EAA+B2C,KACxD,IAAIC,EAAQ,EAEZ,MAAMC,EAAQ7C,IACZ,MAAM8C,EAAcJ,EAAaE,KACjC,OAAIE,EACKA,EAAYH,MAAM3C,EAAS6C,GAE7BF,EAAM3C,EAAQ,EAGvB,OAAO6C,EAAK7C,EAAQ,CAEE,4CDgD0BD,MAAOC,EAAS6C,KAClE,MAAMxC,OAAEA,EAAMC,OAAEA,EAAMC,UAAEA,EAASC,aAAEA,EAAYf,YAAEA,GAAgBO,EAEjE,GAAIQ,GAAcuC,OAAQ,CACxB,MAAMC,QAAEA,EAAO7C,QAAEA,EAAO8C,yBAAEA,GAA6BzC,EAAauC,OAC9DG,EAAU3C,EAAU2C,QACpBC,OAAmDC,IAArC5C,EAAa6B,oBAC3BpC,EAAMgD,GAA4BC,GAAWD,EAAyBC,GAAWD,EAAyBC,GAAW,CAACF,EAASE,GAASf,KAAK,UACvIiB,IAARnD,GACF+B,QAAQC,IAAI,uCAEd,MAAM/B,EAAW,CACfG,SACAC,SACAC,YACAC,eACAf,eAEF,OAAI0D,QACWrD,EAAiBE,EAASC,EAAKC,EAAUC,QA9BxCJ,OAAOE,EAAaC,KACtC,MAAMmD,QAAiB1C,MAAMV,EAAK,CAChCY,OAAQ,OACRD,QAAS,CACP,eAAgB,oBAElBE,KAAMC,KAAKC,UAAUd,KAEvB,aAAamD,EAASC,MAAM,EAwBbC,CAAYtD,EAAKC,GAEhC,OAAO2C,EAAK7C,EAAQ,8BD3EwCD,MAAOC,EAAS6C,KAC5E,MAAMrD,YAAEA,EAAWC,YAAEA,GAAgBO,EAQrC,OANIR,GACuB,UAArBA,EAAYgE,MACdjE,EAAoBC,EAAaC,GAAe,IAI7CoD,EAAK7C,EAAQ,+BDrBwByD,GACG1D,MAAOC,EAAS6C,KACzD7C,EAAQO,UAAUmD,WACpB1D,EAAQQ,aAAa6B,oBAAuBsB,IAC1CF,EAASzD,EAAS2D,EAAK,GAGpBd,EAAK7C"}