{"version":3,"file":"bundle.cjs.js","sources":["../src/utils/utils.ts","../src/utils/nodeUtils.ts","../src/type.ts","../src/transaction_log.ts","../src/node.ts","../src/utils/prop_function.ts","../src/utils/data_source.ts","../src/utils/result.ts","../src/validators/common.ts","../src/validators/graph_data_validator.ts","../src/validator.ts","../src/validators/nodeValidator.ts","../src/validators/static_node_validator.ts","../src/validators/computed_node_validator.ts","../src/validators/agent_validator.ts","../src/validators/relation_validator.ts","../src/task_manager.ts","../src/graphai.ts"],"sourcesContent":["import { DataSource, AgentFunction, DefaultInputData } from \"@/type\";\n\nexport const sleep = async (milliseconds: number) => {\n  return await new Promise((resolve) => setTimeout(resolve, milliseconds));\n};\n\nexport const parseNodeName = (inputNodeId: any): DataSource => {\n  if (typeof inputNodeId === \"string\") {\n    const regex = /^:(.*)$/;\n    const match = inputNodeId.match(regex);\n    if (!match) {\n      return { value: inputNodeId }; // string literal\n    }\n    const parts = match[1].split(\".\");\n    if (parts.length == 1) {\n      return { nodeId: parts[0] };\n    }\n    return { nodeId: parts[0], propIds: parts.slice(1) };\n  }\n  return { value: inputNodeId }; // non-string literal\n};\n\nexport function assert(condition: boolean, message: string, isWarn: boolean = false): asserts condition {\n  if (!condition) {\n    if (!isWarn) {\n      throw new Error(message);\n    }\n    console.warn(\"warn: \" + message);\n  }\n}\n\nexport const isObject = (x: unknown) => {\n  return x !== null && typeof x === \"object\";\n};\n\nexport const isNull = (data: unknown) => {\n  return data === null || data === undefined;\n};\n\nexport const strIntentionalError = \"Intentional Error for Debugging\";\n\nexport const defaultAgentInfo = {\n  name: \"defaultAgentInfo\",\n  samples: [\n    {\n      inputs: [],\n      params: {},\n      result: {},\n    },\n  ],\n  description: \"\",\n  category: [],\n  author: \"\",\n  repository: \"\",\n  license: \"\",\n};\n\nexport const agentInfoWrapper = (agent: AgentFunction<any, any, any>) => {\n  return {\n    agent,\n    mock: agent,\n    ...defaultAgentInfo,\n  };\n};\n\nconst objectToKeyArray = (innerData: any) => {\n  const ret: string[][] = [];\n  Object.keys(innerData).forEach((key: string) => {\n    ret.push([key]);\n    if (Object.keys(innerData[key]).length > 0) {\n      objectToKeyArray(innerData[key]).forEach((tmp: string[]) => {\n        ret.push([key, ...tmp]);\n      });\n    }\n  });\n  return ret;\n};\n\nexport const debugResultKey = (agentId: string, result: any) => {\n  return objectToKeyArray({ [agentId]: debugResultKeyInner(result) }).map((objectKeys: string[]) => {\n    return \":\" + objectKeys.join(\".\");\n  });\n};\n\nconst debugResultKeyInner = (result: any) => {\n  if (result === null || result === undefined) {\n    return {};\n  }\n  if (typeof result === \"string\") {\n    return {};\n  }\n  if (Array.isArray(result)) {\n    return Array.from(result.keys()).reduce((tmp: Record<string, any>, index: number) => {\n      tmp[\"$\" + String(index)] = debugResultKeyInner(result[index]);\n      return tmp;\n    }, {});\n  }\n  return Object.keys(result).reduce((tmp: Record<string, any>, key: string) => {\n    tmp[key] = debugResultKeyInner(result[key]);\n    return tmp;\n  }, {});\n};\n\nexport const isLogicallyTrue = (value: any) => {\n  // Notice that empty aray is not true under GraphAI\n  if (Array.isArray(value) ? value.length === 0 : !value) {\n    return false;\n  }\n  return true;\n};\n\nexport const defaultTestContext = {\n  debugInfo: {\n    nodeId: \"test\",\n    retry: 0,\n    verbose: true,\n  },\n  params: {},\n  filterParams: {},\n  agents: {},\n  log: [],\n};\n\nexport const isNamedInputs = <NamedInput = DefaultInputData>(namedInputs: NamedInput) => {\n  return isObject(namedInputs) && !Array.isArray(namedInputs) && Object.keys(namedInputs || {}).length > 0;\n};\n","import { parseNodeName, isObject } from \"./utils\";\nimport { DataSource } from \"@/type\";\n\n// for dataSource\nexport const inputs2dataSources = (inputs: any): DataSource[] => {\n  if (Array.isArray(inputs)) {\n    return inputs.map((inp) => inputs2dataSources(inp)).flat();\n  }\n  if (isObject(inputs)) {\n    return Object.values(inputs)\n      .map((input) => inputs2dataSources(input))\n      .flat();\n  }\n  if (typeof inputs === \"string\") {\n    const templateMatch = [...inputs.matchAll(/\\${(:[^}]+)}/g)].map((m) => m[1]);\n    if (templateMatch.length > 0) {\n      return inputs2dataSources(templateMatch);\n    }\n  }\n\n  return parseNodeName(inputs) as any;\n};\n\nexport const dataSourceNodeIds = (sources: DataSource[]): string[] => {\n  return sources.filter((source: DataSource) => source.nodeId).map((source) => source.nodeId!);\n};\n","import type { TransactionLog } from \"@/transaction_log\";\nimport type { TaskManager } from \"@/task_manager\";\n\nexport enum NodeState {\n  Waiting = \"waiting\",\n  Queued = \"queued\",\n  Executing = \"executing\",\n  ExecutingServer = \"executing-server\",\n  Failed = \"failed\",\n  TimedOut = \"timed-out\",\n  Completed = \"completed\",\n  Injected = \"injected\",\n  Skipped = \"skipped\",\n}\n\nexport type DefaultResultData = Record<string, any> | string | number | boolean | Array<DefaultResultData>;\nexport type DefaultInputData = Record<string, any>;\nexport type ResultData<ResultType = DefaultResultData> = ResultType | undefined;\nexport type ResultDataDictionary<ResultType = DefaultResultData> = Record<string, ResultData<ResultType>>;\n\nexport type DefaultParamsType = Record<string, any>;\nexport type NodeDataParams<ParamsType = DefaultParamsType> = ParamsType; // Agent-specific parameters\n\nexport type PassThrough = Record<string, any>;\n\nexport type DataSource = {\n  nodeId?: string;\n  value?: any;\n  propIds?: string[];\n};\n\nexport type StaticNodeData = {\n  value?: ResultData; // initial value for static node.\n  update?: string; // nodeId (+.propId) to get value after a loop\n  isResult?: boolean;\n  console?: Record<string, string | boolean>;\n};\nexport type AgentAnonymousFunction = (...params: any[]) => unknown;\n\nexport type AgentFilterParams = Record<string, any>;\n\nexport type GraphDataLoaderOption = { fileName: string; option?: any };\n\nexport type ComputedNodeData = {\n  agent: string | AgentAnonymousFunction;\n  inputs?: Array<any> | Record<string, any>;\n  anyInput?: boolean; // any input makes this node ready\n  params?: NodeDataParams;\n  filterParams?: AgentFilterParams; // agent filter\n  retry?: number;\n  timeout?: number; // msec\n  if?: string; // conditional execution\n  unless?: string; // conditional execution\n  defaultValue?: ResultData;\n  graph?: GraphData | string;\n  graphLoader?: GraphDataLoaderOption;\n  isResult?: boolean;\n  priority?: number; // The default is 0.\n  passThrough?: PassThrough; // data that pass trough to result\n  console?: Record<string, string | boolean>;\n};\n\nexport type NodeData = StaticNodeData | ComputedNodeData;\n\nexport type LoopData = {\n  count?: number;\n  while?: string;\n};\n\nexport type GraphData = {\n  version?: number; // major version, 0.1, 0.2, ...\n  nodes: Record<string, NodeData>;\n  concurrency?: number;\n  loop?: LoopData;\n  verbose?: boolean;\n  retry?: number;\n  metadata?: any; // Stores information about GraphData. GraphAI itself is not used this data.\n};\n\nexport type GraphDataLoader = (loaderOption: GraphDataLoaderOption) => GraphData;\n\nexport type GraphOptions = {\n  agentFilters?: AgentFilterInfo[] | undefined;\n  taskManager?: TaskManager | undefined;\n  bypassAgentIds?: string[] | undefined;\n  config?: Record<string, unknown>;\n  graphLoader?: GraphDataLoader;\n};\n\nexport type CacheTypes = \"pureAgent\" | \"impureAgent\";\n\nexport type AgentFunctionContext<ParamsType = DefaultParamsType, NamedInputDataType = DefaultInputData> = {\n  params: NodeDataParams<ParamsType>;\n  inputSchema?: any;\n  namedInputs: NamedInputDataType;\n  debugInfo: {\n    verbose: boolean;\n    nodeId: string;\n    retry: number;\n    agentId?: string;\n    version?: number;\n    isResult?: boolean;\n  };\n  // graphData?: GraphData; // for nested graph. TODO remove next version.\n  // agents?: AgentFunctionInfoDictionary; // for nested graph. TODO remove next version.\n  // taskManager?: TaskManager; // for nested graph. TODO remove next version.\n  forNestedGraph?: {\n    graphData: GraphData; // nested graph\n    agents: AgentFunctionInfoDictionary; // for nested graph\n    graphOptions: GraphOptions;\n    onLogCallback?: (log: TransactionLog, isUpdate: boolean) => void;\n  };\n  cacheType?: CacheTypes;\n  onLogCallback?: (log: TransactionLog, isUpdate: boolean) => void; // TODO remove next version.\n  filterParams: AgentFilterParams; // agent filter\n  agentFilters?: AgentFilterInfo[];\n  log?: TransactionLog[];\n  config?: Record<string, unknown>;\n};\n\nexport type AgentFunction<ParamsType = DefaultParamsType, ResultType = DefaultResultData, NamedInputDataType = DefaultInputData> = (\n  context: AgentFunctionContext<ParamsType, NamedInputDataType>,\n) => Promise<ResultData<ResultType>>;\n\nexport type AgentFilterFunction<ParamsType = DefaultParamsType, ResultType = DefaultResultData, NamedInputDataType = DefaultInputData> = (\n  context: AgentFunctionContext<ParamsType, NamedInputDataType>,\n  agent: AgentFunction,\n) => Promise<ResultData<ResultType>>;\n\nexport type AgentFilterInfo = {\n  name: string;\n  agent: AgentFilterFunction;\n  agentIds?: string[];\n  nodeIds?: string[];\n  filterParams?: AgentFilterParams;\n};\n\nexport type AgentFunctionInfoSample = {\n  inputs: any;\n  params: DefaultParamsType;\n  result: any;\n  graph?: GraphData;\n};\n\nexport type AgentFunctionInfo = {\n  name: string;\n  agent: AgentFunction<any, any, any>;\n  mock: AgentFunction<any, any, any>;\n  inputs?: any;\n  output?: any;\n  outputFormat?: any;\n  params?: any;\n  samples: AgentFunctionInfoSample[];\n  description: string;\n  category: string[];\n  author: string;\n  repository: string;\n  license: string;\n  cacheType?: CacheTypes;\n  environmentVariables?: string[];\n  stream?: boolean;\n  apiKeys?: string[];\n  npms?: string[];\n};\n\nexport type AgentFunctionInfoDictionary = Record<string, AgentFunctionInfo>;\n\nexport type PropFunction = (result: ResultData, propId: string) => ResultData;\n","import { ResultData, NodeDataParams, NodeState } from \"@/type\";\nimport type { GraphAI } from \"@/graphai\";\nimport type { ComputedNode, StaticNode } from \"@/node\";\nimport { debugResultKey } from \"@/utils/utils\";\nimport { dataSourceNodeIds } from \"@/utils/nodeUtils\";\n\nexport class TransactionLog {\n  public nodeId: string;\n  public state: NodeState;\n  public startTime?: number;\n  public endTime?: number;\n  public retryCount?: number;\n  public agentId?: string;\n  public params?: NodeDataParams;\n  public inputs?: string[];\n  public inputsData?: Array<ResultData>;\n  public injectFrom?: string;\n  public errorMessage?: string;\n  public result?: ResultData;\n  public resultKeys?: string[];\n  public mapIndex?: number;\n  public isLoop?: boolean;\n  public repeatCount?: number;\n  public log?: TransactionLog[];\n  constructor(nodeId: string) {\n    this.nodeId = nodeId;\n    this.state = NodeState.Waiting;\n  }\n\n  public initForComputedNode(node: ComputedNode, graph: GraphAI) {\n    this.agentId = node.getAgentId();\n    this.params = node.params;\n    graph.appendLog(this);\n  }\n\n  public onInjected(node: StaticNode, graph: GraphAI, injectFrom?: string) {\n    const isUpdating = \"endTime\" in this;\n    this.result = node.result;\n    this.state = node.state;\n    this.endTime = Date.now();\n    this.injectFrom = injectFrom;\n    graph.setLoopLog(this);\n    // console.log(this)\n    if (isUpdating) {\n      graph.updateLog(this);\n    } else {\n      graph.appendLog(this);\n    }\n  }\n\n  public onComplete(node: ComputedNode, graph: GraphAI, localLog: TransactionLog[]) {\n    this.result = node.result;\n    this.resultKeys = debugResultKey(this.agentId || \"\", node.result);\n    this.state = node.state;\n    this.endTime = Date.now();\n    graph.setLoopLog(this);\n    if (localLog.length > 0) {\n      this.log = localLog;\n    }\n    graph.updateLog(this);\n  }\n\n  public beforeExecute(node: ComputedNode, graph: GraphAI, transactionId: number, inputs: ResultData[]) {\n    this.state = node.state;\n    this.retryCount = node.retryCount > 0 ? node.retryCount : undefined;\n    this.startTime = transactionId;\n    this.inputs = dataSourceNodeIds(node.dataSources);\n    this.inputsData = inputs.length > 0 ? inputs : undefined;\n    graph.setLoopLog(this);\n    graph.appendLog(this);\n  }\n\n  public beforeAddTask(node: ComputedNode, graph: GraphAI) {\n    this.state = node.state;\n    graph.setLoopLog(this);\n    graph.appendLog(this);\n  }\n\n  public onError(node: ComputedNode, graph: GraphAI, errorMessage: string) {\n    this.state = node.state;\n    this.errorMessage = errorMessage;\n    this.endTime = Date.now();\n    graph.setLoopLog(this);\n    graph.updateLog(this);\n  }\n\n  public onSkipped(node: ComputedNode, graph: GraphAI) {\n    this.state = node.state;\n    graph.setLoopLog(this);\n    graph.updateLog(this);\n  }\n}\n","import type { GraphAI, GraphData } from \"@/index\";\nimport { strIntentionalError } from \"@/utils/utils\";\nimport { inputs2dataSources, dataSourceNodeIds } from \"@/utils/nodeUtils\";\n\nimport {\n  NodeDataParams,\n  ResultData,\n  DataSource,\n  ComputedNodeData,\n  StaticNodeData,\n  NodeState,\n  AgentFunctionContext,\n  AgentFunction,\n  AgentFilterInfo,\n  AgentFilterParams,\n  DefaultParamsType,\n  DefaultInputData,\n  PassThrough,\n} from \"@/type\";\nimport { parseNodeName, assert, isLogicallyTrue, isObject } from \"@/utils/utils\";\nimport { TransactionLog } from \"@/transaction_log\";\n\nexport class Node {\n  public readonly nodeId: string;\n  public readonly waitlist = new Set<string>(); // List of nodes which need data from this node.\n  public state = NodeState.Waiting;\n  public result: ResultData | undefined = undefined;\n\n  protected graph: GraphAI;\n  protected log: TransactionLog;\n  protected console: Record<string, string | boolean>; // console output option (before and/or after)\n\n  constructor(nodeId: string, graph: GraphAI) {\n    this.nodeId = nodeId;\n    this.graph = graph;\n    this.log = new TransactionLog(nodeId);\n    this.console = {};\n  }\n\n  public asString() {\n    return `${this.nodeId}: ${this.state} ${[...this.waitlist]}`;\n  }\n\n  // This method is called either as the result of computation (computed node) or\n  // injection (static node).\n  protected onSetResult() {\n    this.waitlist.forEach((waitingNodeId) => {\n      const waitingNode = this.graph.nodes[waitingNodeId];\n      if (waitingNode.isComputedNode) {\n        waitingNode.removePending(this.nodeId);\n        this.graph.pushQueueIfReadyAndRunning(waitingNode);\n      }\n    });\n  }\n\n  protected afterConsoleLog(result: ResultData) {\n    if (this.console.after === true) {\n      console.log(typeof result === \"string\" ? result : JSON.stringify(result, null, 2));\n    } else if (this.console.after) {\n      console.log(this.console.after);\n    }\n  }\n}\n\nexport class ComputedNode extends Node {\n  public readonly graphId: string;\n  public readonly isResult: boolean;\n  public readonly params: NodeDataParams; // Agent-specific parameters\n  private readonly filterParams: AgentFilterParams;\n  public readonly nestedGraph?: GraphData | DataSource;\n  public readonly retryLimit: number;\n  public retryCount: number = 0;\n  private readonly agentId?: string;\n  private readonly agentFunction?: AgentFunction<any, any, any>;\n  public readonly timeout?: number; // msec\n  public readonly priority: number;\n  public error?: Error;\n  public transactionId: undefined | number; // To reject callbacks from timed-out transactions\n  private readonly passThrough?: PassThrough;\n\n  public readonly anyInput: boolean; // any input makes this node ready\n  public dataSources: DataSource[] = []; // no longer needed. This is for transaction log.\n  private inputs?: Record<string, any>;\n  public pendings: Set<string>; // List of nodes this node is waiting data from.\n  private ifSource?: DataSource; // conditional execution\n  private unlessSource?: DataSource; // conditional execution\n  private defaultValue?: ResultData;\n  private isSkip: boolean = false;\n\n  public readonly isStaticNode = false;\n  public readonly isComputedNode = true;\n\n  constructor(graphId: string, nodeId: string, data: ComputedNodeData, graph: GraphAI) {\n    super(nodeId, graph);\n    this.graphId = graphId;\n    this.params = data.params ?? {};\n    this.console = data.console ?? {};\n    this.filterParams = data.filterParams ?? {};\n    this.passThrough = data.passThrough;\n    this.retryLimit = data.retry ?? graph.retryLimit ?? 0;\n    this.timeout = data.timeout;\n    this.isResult = data.isResult ?? false;\n    this.priority = data.priority ?? 0;\n\n    this.anyInput = data.anyInput ?? false;\n    this.inputs = data.inputs;\n    this.dataSources = [...(data.inputs ? inputs2dataSources(data.inputs).flat(10) : []), ...(data.params ? inputs2dataSources(data.params).flat(10) : [])];\n    if (data.inputs && Array.isArray(data.inputs)) {\n      throw new Error(`array inputs have been deprecated. nodeId: ${nodeId}: see https://github.com/receptron/graphai/blob/main/docs/NamedInputs.md`);\n    }\n\n    this.pendings = new Set(dataSourceNodeIds(this.dataSources));\n    assert([\"function\", \"string\"].includes(typeof data.agent), \"agent must be either string or function\");\n    if (typeof data.agent === \"string\") {\n      this.agentId = data.agent;\n    } else {\n      const agent = data.agent;\n      this.agentFunction = async ({ namedInputs, params }) => agent(namedInputs, params);\n    }\n    if (data.graph) {\n      this.nestedGraph = typeof data.graph === \"string\" ? this.addPendingNode(data.graph) : data.graph;\n    }\n    if (data.graphLoader && graph.graphLoader) {\n      this.nestedGraph = graph.graphLoader(data.graphLoader);\n    }\n    if (data.if) {\n      this.ifSource = this.addPendingNode(data.if);\n    }\n    if (data.unless) {\n      this.unlessSource = this.addPendingNode(data.unless);\n    }\n    if (data.defaultValue) {\n      this.defaultValue = data.defaultValue;\n    }\n    this.isSkip = false;\n    this.log.initForComputedNode(this, graph);\n  }\n\n  public getAgentId() {\n    return this.agentId ?? \"__custom__function\"; // only for display purpose in the log.\n  }\n\n  private addPendingNode(nodeId: string) {\n    const source = parseNodeName(nodeId);\n    assert(!!source.nodeId, `Invalid data source ${nodeId}`);\n    this.pendings.add(source.nodeId);\n    return source;\n  }\n\n  public isReadyNode() {\n    if (this.state !== NodeState.Waiting || this.pendings.size !== 0) {\n      return false;\n    }\n    this.isSkip = !!(\n      (this.ifSource && !isLogicallyTrue(this.graph.resultOf(this.ifSource))) ||\n      (this.unlessSource && isLogicallyTrue(this.graph.resultOf(this.unlessSource)))\n    );\n\n    if (this.isSkip && this.defaultValue === undefined) {\n      this.state = NodeState.Skipped;\n      this.log.onSkipped(this, this.graph);\n      return false;\n    }\n    return true;\n  }\n\n  // This private method (only called while executing execute()) performs\n  // the \"retry\" if specified. The transaction log must be updated before\n  // callling this method.\n  private retry(state: NodeState, error: Error) {\n    this.state = state; // this.execute() will update to NodeState.Executing\n    this.log.onError(this, this.graph, error.message);\n\n    if (this.retryCount < this.retryLimit) {\n      this.retryCount++;\n      this.execute();\n    } else {\n      this.result = undefined;\n      this.error = error;\n      this.transactionId = undefined; // This is necessary for timeout case\n      this.graph.onExecutionComplete(this);\n    }\n  }\n\n  private checkDataAvailability() {\n    return Object.values(this.graph.resultsOf(this.inputs))\n      .flat()\n      .some((result) => result !== undefined);\n  }\n\n  // This method is called right before the Graph add this node to the task manager.\n  public beforeAddTask() {\n    this.state = NodeState.Queued;\n    this.log.beforeAddTask(this, this.graph);\n  }\n\n  // This method is called when the data became available on one of nodes,\n  // which this node needs data from.\n  public removePending(nodeId: string) {\n    if (this.anyInput) {\n      if (this.checkDataAvailability()) {\n        this.pendings.clear();\n      }\n    } else {\n      this.pendings.delete(nodeId);\n    }\n  }\n\n  private isCurrentTransaction(transactionId: number) {\n    return this.transactionId === transactionId;\n  }\n\n  // This private method (called only fro execute) checks if the callback from\n  // the timer came before the completion of agent function call, record it\n  // and attempt to retry (if specified).\n  private executeTimeout(transactionId: number) {\n    if (this.state === NodeState.Executing && this.isCurrentTransaction(transactionId)) {\n      console.warn(`-- timeout ${this.timeout} with ${this.nodeId}`);\n      this.retry(NodeState.TimedOut, Error(\"Timeout\"));\n    }\n  }\n\n  // Check if we need to apply this filter to this node or not.\n  private shouldApplyAgentFilter(agentFilter: AgentFilterInfo) {\n    if (agentFilter.agentIds && Array.isArray(agentFilter.agentIds) && agentFilter.agentIds.length > 0) {\n      if (this.agentId && agentFilter.agentIds.includes(this.agentId)) {\n        return true;\n      }\n    }\n    if (agentFilter.nodeIds && Array.isArray(agentFilter.nodeIds) && agentFilter.nodeIds.length > 0) {\n      if (agentFilter.nodeIds.includes(this.nodeId)) {\n        return true;\n      }\n    }\n    return !agentFilter.agentIds && !agentFilter.nodeIds;\n  }\n\n  private agentFilterHandler(context: AgentFunctionContext, agentFunction: AgentFunction): Promise<ResultData> {\n    let index = 0;\n\n    const next = (innerContext: AgentFunctionContext): Promise<ResultData> => {\n      const agentFilter = this.graph.agentFilters[index++];\n      if (agentFilter) {\n        if (this.shouldApplyAgentFilter(agentFilter)) {\n          if (agentFilter.filterParams) {\n            innerContext.filterParams = { ...agentFilter.filterParams, ...innerContext.filterParams };\n          }\n          return agentFilter.agent(innerContext, next);\n        }\n        return next(innerContext);\n      }\n      return agentFunction(innerContext);\n    };\n\n    return next(context);\n  }\n\n  // This method is called when this computed node became ready to run.\n  // It asynchronously calls the associated with agent function and set the result,\n  // then it removes itself from the \"running node\" list of the graph.\n  // Notice that setting the result of this node may make other nodes ready to run.\n  public async execute() {\n    if (this.isSkip) {\n      this.afterExecute(this.defaultValue, []);\n      return;\n    }\n    const previousResults = this.graph.resultsOf(this.inputs, this.anyInput);\n    const transactionId = Date.now();\n    this.prepareExecute(transactionId, Object.values(previousResults));\n\n    if (this.timeout && this.timeout > 0) {\n      setTimeout(() => {\n        this.executeTimeout(transactionId);\n      }, this.timeout);\n    }\n\n    try {\n      const agentFunction = this.agentFunction ?? this.graph.getAgentFunctionInfo(this.agentId).agent;\n      const localLog: TransactionLog[] = [];\n      const context = this.getContext(previousResults, localLog);\n\n      // NOTE: We use the existence of graph object in the agent-specific params to determine\n      // if this is a nested agent or not.\n      if (this.nestedGraph) {\n        this.graph.taskManager.prepareForNesting();\n        context.onLogCallback = this.graph.onLogCallback;\n        context.forNestedGraph = {\n          graphData: \"nodes\" in this.nestedGraph ? this.nestedGraph : (this.graph.resultOf(this.nestedGraph) as GraphData), // HACK: compiler work-around\n          agents: this.graph.agentFunctionInfoDictionary,\n          graphOptions: {\n            agentFilters: this.graph.agentFilters,\n            taskManager: this.graph.taskManager,\n            bypassAgentIds: this.graph.bypassAgentIds,\n            config: this.graph.config,\n            graphLoader: this.graph.graphLoader,\n          },\n          onLogCallback: this.graph.onLogCallback,\n        };\n      }\n\n      this.beforeConsoleLog(context);\n      const result = await this.agentFilterHandler(context as AgentFunctionContext, agentFunction);\n      this.afterConsoleLog(result);\n\n      if (this.nestedGraph) {\n        this.graph.taskManager.restoreAfterNesting();\n      }\n\n      if (!this.isCurrentTransaction(transactionId)) {\n        // This condition happens when the agent function returns\n        // after the timeout (either retried or not).\n        console.log(`-- transactionId mismatch with ${this.nodeId} (probably timeout)`);\n        return;\n      }\n\n      // after process\n      this.afterExecute(result, localLog);\n    } catch (error) {\n      this.errorProcess(error, transactionId, previousResults);\n    }\n  }\n\n  private afterExecute(result: ResultData, localLog: TransactionLog[]) {\n    this.state = NodeState.Completed;\n    this.result = this.getResult(result);\n    this.log.onComplete(this, this.graph, localLog);\n\n    this.onSetResult();\n\n    this.graph.onExecutionComplete(this);\n  }\n\n  // This private method (called only by execute()) prepares the ComputedNode object\n  // for execution, and create a new transaction to record it.\n  private prepareExecute(transactionId: number, inputs: Array<ResultData>) {\n    this.state = NodeState.Executing;\n    this.log.beforeExecute(this, this.graph, transactionId, inputs);\n    this.transactionId = transactionId;\n  }\n\n  // This private method (called only by execute) processes an error received from\n  // the agent function. It records the error in the transaction log and handles\n  // the retry if specified.\n  private errorProcess(error: unknown, transactionId: number, namedInputs: DefaultInputData) {\n    if (error instanceof Error && error.message !== strIntentionalError) {\n      console.error(`<-- NodeId: ${this.nodeId}, Agent: ${this.agentId}`);\n      console.error({ namedInputs });\n      console.error(error);\n      console.error(\"-->\");\n    }\n    if (!this.isCurrentTransaction(transactionId)) {\n      console.warn(`-- transactionId mismatch with ${this.nodeId} (not timeout)`);\n      return;\n    }\n\n    if (error instanceof Error) {\n      this.retry(NodeState.Failed, error);\n    } else {\n      console.error(`-- NodeId: ${this.nodeId}: Unknown error was caught`);\n      this.retry(NodeState.Failed, Error(\"Unknown\"));\n    }\n  }\n\n  private getContext(previousResults: Record<string, ResultData | undefined>, localLog: TransactionLog[]) {\n    const context: AgentFunctionContext<DefaultParamsType, DefaultInputData | string | number | boolean | undefined> = {\n      params: this.graph.resultsOf(this.params),\n      namedInputs: previousResults,\n      inputSchema: this.agentFunction ? undefined : this.graph.getAgentFunctionInfo(this.agentId)?.inputs,\n      debugInfo: this.getDebugInfo(),\n      cacheType: this.agentFunction ? undefined : this.graph.getAgentFunctionInfo(this.agentId)?.cacheType,\n      filterParams: this.filterParams,\n      agentFilters: this.graph.agentFilters,\n      config: this.graph.config,\n      log: localLog,\n    };\n    return context;\n  }\n\n  private getResult(result: ResultData) {\n    if (result && this.passThrough) {\n      if (isObject(result) && !Array.isArray(result)) {\n        return { ...result, ...this.passThrough };\n      } else if (Array.isArray(result)) {\n        return result.map((r) => (isObject(r) && !Array.isArray(r) ? { ...r, ...this.passThrough } : r));\n      }\n    }\n    return result;\n  }\n\n  private getDebugInfo() {\n    return {\n      nodeId: this.nodeId,\n      agentId: this.agentId,\n      retry: this.retryCount,\n      verbose: this.graph.verbose,\n      version: this.graph.version,\n      isResult: this.isResult,\n    };\n  }\n\n  private beforeConsoleLog(context: AgentFunctionContext<DefaultParamsType, string | number | boolean | DefaultInputData | undefined>) {\n    if (this.console.before === true) {\n      console.log(JSON.stringify(context.namedInputs, null, 2));\n    } else if (this.console.before) {\n      console.log(this.console.before);\n    }\n  }\n}\n\nexport class StaticNode extends Node {\n  public value?: ResultData;\n  public readonly update?: DataSource;\n  public readonly isResult: boolean;\n  public readonly isStaticNode = true;\n  public readonly isComputedNode = false;\n\n  constructor(nodeId: string, data: StaticNodeData, graph: GraphAI) {\n    super(nodeId, graph);\n    this.value = data.value;\n    this.update = data.update ? parseNodeName(data.update) : undefined;\n    this.isResult = data.isResult ?? false;\n    this.console = data.console ?? {};\n  }\n\n  public injectValue(value: ResultData, injectFrom?: string) {\n    this.state = NodeState.Injected;\n    this.result = value;\n    this.log.onInjected(this, this.graph, injectFrom);\n    this.onSetResult();\n  }\n\n  public consoleLog() {\n    this.afterConsoleLog(this.result);\n  }\n}\n\nexport type GraphNodes = Record<string, ComputedNode | StaticNode>;\n","import { PropFunction } from \"@/type\";\nimport { isObject } from \"./utils\";\n\nexport const propFunctionRegex = /^[a-zA-Z]+\\([^)]*\\)$/;\n\nconst propArrayFunction: PropFunction = (result, propId) => {\n  if (Array.isArray(result)) {\n    if (propId === \"length()\") {\n      return result.length;\n    }\n    if (propId === \"flat()\") {\n      return result.flat();\n    }\n    if (propId === \"toJSON()\") {\n      return JSON.stringify(result);\n    }\n    if (propId === \"isEmpty()\") {\n      return result.length === 0;\n    }\n    // array join\n    const matchJoin = propId.match(/^join\\(([,-\\s]?)\\)$/);\n    if (matchJoin && Array.isArray(matchJoin)) {\n      return result.join(matchJoin[1] ?? \"\");\n    }\n  }\n  return undefined;\n};\n\nconst propObjectFunction: PropFunction = (result, propId) => {\n  if (isObject(result)) {\n    if (propId === \"keys()\") {\n      return Object.keys(result);\n    }\n    if (propId === \"values()\") {\n      return Object.values(result);\n    }\n    if (propId === \"toJSON()\") {\n      return JSON.stringify(result);\n    }\n  }\n  return undefined;\n};\n\nconst propStringFunction: PropFunction = (result, propId) => {\n  if (typeof result === \"string\") {\n    if (propId === \"codeBlock()\") {\n      const match = (\"\\n\" + result).match(/\\n```[a-zA-z]*([\\s\\S]*?)\\n```/);\n      if (match) {\n        return match[1];\n      }\n    }\n    if (propId === \"jsonParse()\") {\n      return JSON.parse(result);\n    }\n    if (propId === \"toNumber()\") {\n      const ret = Number(result);\n      if (!isNaN(ret)) {\n        return ret;\n      }\n    }\n    if (propId === \"trim()\") {\n      return result.trim();\n    }\n    if (propId === \"toLowerCase()\") {\n      return result.toLowerCase();\n    }\n    if (propId === \"toUpperCase()\") {\n      return result.toUpperCase();\n    }\n    // split()\n  }\n  return undefined;\n};\nconst propNumberFunction: PropFunction = (result, propId) => {\n  if (result !== undefined && Number.isFinite(result)) {\n    if (propId === \"toString()\") {\n      return String(result);\n    }\n    const regex = /^add\\((-?\\d+)\\)$/;\n    const match = propId.match(regex);\n    if (match) {\n      return Number(result) + Number(match[1]);\n    }\n  }\n  return undefined;\n};\nconst propBooleanFunction: PropFunction = (result, propId) => {\n  if (typeof result === \"boolean\") {\n    if (propId === \"not()\") {\n      return !result;\n    }\n  }\n  return undefined;\n};\n\nexport const propFunctions = [propArrayFunction, propObjectFunction, propStringFunction, propNumberFunction, propBooleanFunction];\n","import { ResultData, DataSource, PropFunction } from \"@/type\";\nimport { isObject, isNull } from \"./utils\";\nimport { propFunctionRegex } from \"./prop_function\";\n\nconst getNestedData = (result: ResultData, propId: string, propFunctions: PropFunction[]) => {\n  const match = propId.match(propFunctionRegex);\n  if (match) {\n    for (const propFunction of propFunctions) {\n      const ret = propFunction(result, propId);\n      if (!isNull(ret)) {\n        return ret;\n      }\n    }\n  }\n\n  // for array.\n  if (Array.isArray(result)) {\n    // $0, $1. array value.\n    const regex = /^\\$(\\d+)$/;\n    const match = propId.match(regex);\n    if (match) {\n      const index = parseInt(match[1], 10);\n      return result[index];\n    }\n    if (propId === \"$last\") {\n      return result[result.length - 1];\n    }\n  } else if (isObject(result)) {\n    if (propId in result) {\n      return result[propId];\n    }\n  }\n  return undefined;\n};\n\nconst innerGetDataFromSource = (result: ResultData, propIds: string[] | undefined, propFunctions: PropFunction[]): ResultData | undefined => {\n  if (!isNull(result) && propIds && propIds.length > 0) {\n    const propId = propIds[0];\n    const ret = getNestedData(result, propId, propFunctions);\n    if (ret === undefined) {\n      console.error(`prop: ${propIds.join(\".\")} is not hit`);\n    }\n    if (propIds.length > 1) {\n      return innerGetDataFromSource(ret, propIds.slice(1), propFunctions);\n    }\n    return ret;\n  }\n  return result;\n};\n\nexport const getDataFromSource = (result: ResultData | undefined, source: DataSource, propFunctions: PropFunction[] = []): ResultData | undefined => {\n  if (!source.nodeId) {\n    return source.value;\n  }\n  return innerGetDataFromSource(result, source.propIds, propFunctions);\n};\n","import { DataSource, ResultData, PropFunction } from \"@/type\";\n\nimport { GraphNodes } from \"@/node\";\n\nimport { parseNodeName, isNamedInputs, isObject, isNull } from \"@/utils/utils\";\nimport { getDataFromSource } from \"@/utils/data_source\";\n\nconst resultsOfInner = (input: any, nodes: GraphNodes, propFunctions: PropFunction[]): ResultData => {\n  if (Array.isArray(input)) {\n    return input.map((inp) => resultsOfInner(inp, nodes, propFunctions));\n  }\n  if (isNamedInputs(input)) {\n    return resultsOf(input, nodes, propFunctions);\n  }\n  if (typeof input === \"string\") {\n    const templateMatch = [...input.matchAll(/\\${(:[^}]+)}/g)].map((m) => m[1]);\n    if (templateMatch.length > 0) {\n      const results = resultsOfInner(templateMatch, nodes, propFunctions);\n      return Array.from(templateMatch.keys()).reduce((tmp, key) => {\n        return tmp.replaceAll(\"${\" + templateMatch[key] + \"}\", (results as any)[key]);\n      }, input);\n    }\n  }\n  return resultOf(parseNodeName(input), nodes, propFunctions);\n};\n\nexport const resultsOf = (inputs: Record<string, any> | Array<string>, nodes: GraphNodes, propFunctions: PropFunction[]) => {\n  // for inputs. TODO remove if array input is not supported\n  if (Array.isArray(inputs)) {\n    return inputs.reduce((tmp: Record<string, ResultData>, key) => {\n      tmp[key] = resultsOfInner(key, nodes, propFunctions);\n      return tmp;\n    }, {});\n  }\n  return Object.keys(inputs).reduce((tmp: Record<string, ResultData>, key) => {\n    const input = inputs[key];\n    tmp[key] = isNamedInputs(input) ? resultsOf(input, nodes, propFunctions) : resultsOfInner(input, nodes, propFunctions);\n    return tmp;\n  }, {});\n};\n\nexport const resultOf = (source: DataSource, nodes: GraphNodes, propFunctions: PropFunction[]) => {\n  const { result } = source.nodeId ? nodes[source.nodeId] : { result: undefined };\n  return getDataFromSource(result, source, propFunctions);\n};\n\n// clean up object for anyInput\nexport const cleanResultInner = (results: ResultData): ResultData | null => {\n  if (Array.isArray(results)) {\n    return results.map((result: ResultData) => cleanResultInner(result)).filter((result) => !isNull(result));\n  }\n\n  if (isObject(results)) {\n    return Object.keys(results).reduce((tmp: Record<string, ResultData>, key: string) => {\n      const value = cleanResultInner(results[key]);\n      if (!isNull(value)) {\n        tmp[key] = value;\n      }\n      return tmp;\n    }, {});\n  }\n\n  return results;\n};\n\nexport const cleanResult = (results: Record<string, ResultData | undefined>) => {\n  return Object.keys(results).reduce((tmp: Record<string, ResultData | undefined>, key: string) => {\n    const value = cleanResultInner(results[key]);\n    if (!isNull(value)) {\n      tmp[key] = value;\n    }\n    return tmp;\n  }, {});\n};\n","export const graphDataAttributeKeys = [\"nodes\", \"concurrency\", \"agentId\", \"loop\", \"verbose\", \"version\"];\n\nexport const computedNodeAttributeKeys = [\n  \"inputs\",\n  \"anyInput\",\n  \"params\",\n  \"retry\",\n  \"timeout\",\n  \"agent\",\n  \"graph\",\n  \"graphLoader\",\n  \"isResult\",\n  \"priority\",\n  \"if\",\n  \"unless\",\n  \"defaultValue\",\n  \"filterParams\",\n  \"console\",\n  \"passThrough\",\n];\nexport const staticNodeAttributeKeys = [\"value\", \"update\", \"isResult\", \"console\"];\n\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(`\\x1b[41m${message}\\x1b[0m`); // Pass the message to the base Error class\n\n    // Set the prototype explicitly to ensure correct prototype chain\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n","import { GraphData } from \"@/type\";\nimport { graphDataAttributeKeys, ValidationError } from \"@/validators/common\";\n\nexport const graphNodesValidator = (data: GraphData) => {\n  if (data.nodes === undefined) {\n    throw new ValidationError(\"Invalid Graph Data: no nodes\");\n  }\n  if (typeof data.nodes !== \"object\") {\n    throw new ValidationError(\"Invalid Graph Data: invalid nodes\");\n  }\n  if (Array.isArray(data.nodes)) {\n    throw new ValidationError(\"Invalid Graph Data: nodes must be object\");\n  }\n  if (Object.keys(data.nodes).length === 0) {\n    throw new ValidationError(\"Invalid Graph Data: nodes is empty\");\n  }\n  Object.keys(data).forEach((key) => {\n    if (!graphDataAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Graph Data does not allow \" + key);\n    }\n  });\n};\nexport const graphDataValidator = (data: GraphData) => {\n  if (data.loop) {\n    if (data.loop.count === undefined && data.loop.while === undefined) {\n      throw new ValidationError(\"Loop: Either count or while is required in loop\");\n    }\n    if (data.loop.count !== undefined && data.loop.while !== undefined) {\n      throw new ValidationError(\"Loop: Both count and while cannot be set\");\n    }\n  }\n  if (data.concurrency !== undefined) {\n    if (!Number.isInteger(data.concurrency)) {\n      throw new ValidationError(\"Concurrency must be an integer\");\n    }\n    if (data.concurrency < 1) {\n      throw new ValidationError(\"Concurrency must be a positive integer\");\n    }\n  }\n};\n","import { GraphData } from \"@/type\";\n\nimport { graphNodesValidator, graphDataValidator } from \"@/validators/graph_data_validator\";\nimport { nodeValidator } from \"@/validators/nodeValidator\";\nimport { staticNodeValidator } from \"@/validators/static_node_validator\";\nimport { computedNodeValidator } from \"@/validators/computed_node_validator\";\nimport { relationValidator } from \"@/validators/relation_validator\";\nimport { agentValidator } from \"@/validators/agent_validator\";\n\nexport const validateGraphData = (data: GraphData, agentIds: string[]) => {\n  graphNodesValidator(data);\n  graphDataValidator(data);\n  const computedNodeIds: string[] = [];\n  const staticNodeIds: string[] = [];\n  const graphAgentIds = new Set<string>();\n  Object.keys(data.nodes).forEach((nodeId) => {\n    const node = data.nodes[nodeId];\n    const isStaticNode = !(\"agent\" in node);\n    nodeValidator(node);\n    const agentId = isStaticNode ? \"\" : node.agent;\n    isStaticNode && staticNodeValidator(node) && staticNodeIds.push(nodeId);\n    !isStaticNode && computedNodeValidator(node) && computedNodeIds.push(nodeId) && typeof agentId === \"string\" && graphAgentIds.add(agentId);\n  });\n  agentValidator(graphAgentIds, new Set<string>(agentIds));\n  relationValidator(data, staticNodeIds, computedNodeIds);\n\n  return true;\n};\n","import { NodeData, StaticNodeData, ComputedNodeData } from \"@/type\";\nimport { ValidationError } from \"@/validators/common\";\n\nexport const nodeValidator = (nodeData: NodeData) => {\n  if ((nodeData as ComputedNodeData).agent && (nodeData as StaticNodeData).value) {\n    throw new ValidationError(\"Cannot set both agent and value\");\n  }\n  // if (!(\"agent\" in nodeData) && !(\"value\" in nodeData)) {\n  //   throw new ValidationError(\"Either agent or value is required\");\n  // }\n  return true;\n};\n","import { StaticNodeData } from \"@/type\";\nimport { staticNodeAttributeKeys, ValidationError } from \"@/validators/common\";\n\nexport const staticNodeValidator = (nodeData: StaticNodeData) => {\n  Object.keys(nodeData).forEach((key) => {\n    if (!staticNodeAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Static node does not allow \" + key);\n    }\n  });\n  return true;\n};\n","import { ComputedNodeData } from \"@/type\";\nimport { computedNodeAttributeKeys, ValidationError } from \"@/validators/common\";\n\nexport const computedNodeValidator = (nodeData: ComputedNodeData) => {\n  Object.keys(nodeData).forEach((key) => {\n    if (!computedNodeAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Computed node does not allow \" + key);\n    }\n  });\n  return true;\n};\n","import { ValidationError } from \"@/validators/common\";\n\nexport const agentValidator = (graphAgentIds: Set<string>, agentIds: Set<string>) => {\n  graphAgentIds.forEach((agentId) => {\n    if (!agentIds.has(agentId)) {\n      throw new ValidationError(\"Invalid Agent : \" + agentId + \" is not in AgentFunctionInfoDictionary.\");\n    }\n  });\n  return true;\n};\n","import { GraphData } from \"@/type\";\nimport { parseNodeName } from \"@/utils/utils\";\nimport { ValidationError } from \"@/validators/common\";\nimport { inputs2dataSources, dataSourceNodeIds } from \"@/utils/nodeUtils\";\n\nexport const relationValidator = (data: GraphData, staticNodeIds: string[], computedNodeIds: string[]) => {\n  const nodeIds = new Set<string>(Object.keys(data.nodes));\n\n  const pendings: Record<string, Set<string>> = {};\n  const waitlist: Record<string, Set<string>> = {};\n\n  // validate input relation and set pendings and wait list\n  computedNodeIds.forEach((computedNodeId) => {\n    const nodeData = data.nodes[computedNodeId];\n    pendings[computedNodeId] = new Set<string>();\n\n    const dataSourceValidator = (sourceType: string, sourceNodeIds: string[]) => {\n      sourceNodeIds.forEach((sourceNodeId) => {\n        if (sourceNodeId) {\n          if (!nodeIds.has(sourceNodeId)) {\n            throw new ValidationError(`${sourceType} not match: NodeId ${computedNodeId}, Inputs: ${sourceNodeId}`);\n          }\n          waitlist[sourceNodeId] === undefined && (waitlist[sourceNodeId] = new Set<string>());\n          pendings[computedNodeId].add(sourceNodeId);\n          waitlist[sourceNodeId].add(computedNodeId);\n        }\n      });\n    };\n    if (\"agent\" in nodeData && nodeData) {\n      if (nodeData.inputs) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources(nodeData.inputs));\n        dataSourceValidator(\"Inputs\", sourceNodeIds);\n      }\n      if (nodeData.if) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ if: nodeData.if }));\n        dataSourceValidator(\"If\", sourceNodeIds);\n      }\n      if (nodeData.unless) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ unless: nodeData.unless }));\n        dataSourceValidator(\"Unless\", sourceNodeIds);\n      }\n      if (nodeData.graph && typeof nodeData?.graph === \"string\") {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ graph: nodeData.graph }));\n        dataSourceValidator(\"Graph\", sourceNodeIds);\n      }\n    }\n  });\n\n  // TODO. validate update\n  staticNodeIds.forEach((staticNodeId) => {\n    const nodeData = data.nodes[staticNodeId];\n    if (\"value\" in nodeData && nodeData.update) {\n      const update = nodeData.update;\n      const updateNodeId = parseNodeName(update).nodeId;\n      if (!updateNodeId) {\n        throw new ValidationError(\"Update it a literal\");\n      }\n      if (!nodeIds.has(updateNodeId)) {\n        throw new ValidationError(`Update not match: NodeId ${staticNodeId}, update: ${update}`);\n      }\n    }\n  });\n\n  const cycle = (possibles: string[]) => {\n    possibles.forEach((possobleNodeId) => {\n      (waitlist[possobleNodeId] || []).forEach((waitingNodeId) => {\n        pendings[waitingNodeId].delete(possobleNodeId);\n      });\n    });\n\n    const running: string[] = [];\n    Object.keys(pendings).forEach((pendingNodeId) => {\n      if (pendings[pendingNodeId].size === 0) {\n        running.push(pendingNodeId);\n        delete pendings[pendingNodeId];\n      }\n    });\n    return running;\n  };\n\n  let runningQueue = cycle(staticNodeIds);\n  if (runningQueue.length === 0) {\n    throw new ValidationError(\"No Initial Runnning Node\");\n  }\n\n  do {\n    runningQueue = cycle(runningQueue);\n  } while (runningQueue.length > 0);\n\n  if (Object.keys(pendings).length > 0) {\n    throw new ValidationError(\"Some nodes are not executed: \" + Object.keys(pendings).join(\", \"));\n  }\n};\n","import { ComputedNode } from \"@/node\";\nimport { assert } from \"@/utils/utils\";\n\ntype TaskEntry = {\n  node: ComputedNode;\n  graphId: string;\n  callback: (node: ComputedNode) => void;\n};\n\n// TaskManage object controls the concurrency of ComputedNode execution.\n//\n// NOTE: A TaskManager instance will be shared between parent graph and its children\n// when nested agents are involved.\nexport class TaskManager {\n  private concurrency: number;\n  private taskQueue: Array<TaskEntry> = [];\n  private runningNodes = new Set<ComputedNode>();\n\n  constructor(concurrency: number) {\n    this.concurrency = concurrency;\n  }\n\n  // This internal method dequeus a task from the task queue\n  // and call the associated callback method, if the number of\n  // running task is lower than the spcified limit.\n  private dequeueTaskIfPossible() {\n    if (this.runningNodes.size < this.concurrency) {\n      const task = this.taskQueue.shift();\n      if (task) {\n        this.runningNodes.add(task.node);\n        task.callback(task.node);\n      }\n    }\n  }\n\n  // Node will call this method to put itself in the execution queue.\n  // We call the associated callback function when it is dequeued.\n  public addTask(node: ComputedNode, graphId: string, callback: (node: ComputedNode) => void) {\n    // Finder tasks in the queue, which has either the same or higher priority.\n    const count = this.taskQueue.filter((task) => {\n      return task.node.priority >= node.priority;\n    }).length;\n    assert(count <= this.taskQueue.length, \"TaskManager.addTask: Something is really wrong.\");\n    this.taskQueue.splice(count, 0, { node, graphId, callback });\n    this.dequeueTaskIfPossible();\n  }\n\n  public isRunning(graphId: string) {\n    const count = [...this.runningNodes].filter((node) => {\n      return node.graphId == graphId;\n    }).length;\n    return count > 0 || Array.from(this.taskQueue).filter((data) => data.graphId === graphId).length > 0;\n  }\n\n  // Node MUST call this method once the execution of agent function is completed\n  // either successfully or not.\n  public onComplete(node: ComputedNode) {\n    assert(this.runningNodes.has(node), `TaskManager.onComplete node(${node.nodeId}) is not in list`);\n    this.runningNodes.delete(node);\n    this.dequeueTaskIfPossible();\n  }\n\n  // Node will call this method before it hands the task manager from the graph\n  // to a nested agent. We need to make it sure that there is enough room to run\n  // computed nodes inside the nested graph to avoid a deadlock.\n  public prepareForNesting() {\n    this.concurrency++;\n  }\n\n  public restoreAfterNesting() {\n    this.concurrency--;\n  }\n\n  public getStatus(verbose: boolean = false) {\n    const runningNodes = Array.from(this.runningNodes).map((node) => node.nodeId);\n    const queuedNodes = this.taskQueue.map((task) => task.node.nodeId);\n    const nodes = verbose ? { runningNodes, queuedNodes } : {};\n    return {\n      concurrency: this.concurrency,\n      queue: this.taskQueue.length,\n      running: this.runningNodes.size,\n      ...nodes,\n    };\n  }\n}\n","import {\n  AgentFunctionInfoDictionary,\n  AgentFilterInfo,\n  GraphData,\n  DataSource,\n  LoopData,\n  ResultDataDictionary,\n  ResultData,\n  DefaultResultData,\n  GraphOptions,\n  PropFunction,\n  GraphDataLoader,\n} from \"@/type\";\nimport { TransactionLog } from \"@/transaction_log\";\n\nimport { ComputedNode, StaticNode, GraphNodes } from \"@/node\";\n\nimport { resultsOf, resultOf, cleanResult } from \"@/utils/result\";\nimport { propFunctions } from \"@/utils/prop_function\";\nimport { parseNodeName, assert, isLogicallyTrue } from \"@/utils/utils\";\nimport { getDataFromSource } from \"@/utils/data_source\";\n\nimport { validateGraphData } from \"@/validator\";\nimport { TaskManager } from \"@/task_manager\";\n\nexport const defaultConcurrency = 8;\nexport const graphDataLatestVersion = 0.5;\n\nexport class GraphAI {\n  public readonly version: number;\n  private readonly graphId: string;\n  private readonly data: GraphData;\n  private readonly loop?: LoopData;\n  private readonly logs: Array<TransactionLog> = [];\n  public readonly bypassAgentIds: string[];\n  public readonly config?: Record<string, unknown> = {};\n  public readonly agentFunctionInfoDictionary: AgentFunctionInfoDictionary;\n  public readonly taskManager: TaskManager;\n  public readonly agentFilters: AgentFilterInfo[];\n  public readonly retryLimit?: number;\n  private readonly propFunctions: PropFunction[];\n  public readonly graphLoader?: GraphDataLoader;\n\n  public nodes: GraphNodes;\n  public onLogCallback = (__log: TransactionLog, __isUpdate: boolean) => {};\n  public verbose: boolean; // REVIEW: Do we need this?\n\n  private onComplete: () => void;\n  private repeatCount = 0;\n\n  // This method is called when either the GraphAI obect was created,\n  // or we are about to start n-th iteration (n>2).\n  private createNodes(data: GraphData) {\n    const nodes = Object.keys(data.nodes).reduce((_nodes: GraphNodes, nodeId: string) => {\n      const nodeData = data.nodes[nodeId];\n      if (\"agent\" in nodeData) {\n        _nodes[nodeId] = new ComputedNode(this.graphId, nodeId, nodeData, this);\n      } else {\n        _nodes[nodeId] = new StaticNode(nodeId, nodeData, this);\n      }\n      // throw new Error(\"Unknown node type (neither value nor agent): \" + nodeId);\n      return _nodes;\n    }, {});\n\n    // Generate the waitlist for each node.\n    Object.keys(nodes).forEach((nodeId) => {\n      const node = nodes[nodeId];\n      if (node.isComputedNode) {\n        node.pendings.forEach((pending) => {\n          if (nodes[pending]) {\n            nodes[pending].waitlist.add(nodeId); // previousNode\n          } else {\n            throw new Error(`createNode: invalid input ${pending} for node, ${nodeId}`);\n          }\n        });\n      }\n    });\n    return nodes;\n  }\n\n  private getValueFromResults(source: DataSource, results: ResultDataDictionary<DefaultResultData>) {\n    return getDataFromSource(source.nodeId ? results[source.nodeId] : undefined, source, this.propFunctions);\n  }\n\n  // for static\n  private initializeStaticNodes(enableConsoleLog: boolean = false) {\n    // If the result property is specified, inject it.\n    // If the previousResults exists (indicating we are in a loop),\n    // process the update property (nodeId or nodeId.propId).\n    Object.keys(this.data.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node?.isStaticNode) {\n        const value = node?.value;\n        if (value !== undefined) {\n          this.injectValue(nodeId, value, nodeId);\n        }\n        if (enableConsoleLog) {\n          node.consoleLog();\n        }\n      }\n    });\n  }\n\n  private updateStaticNodes(previousResults?: ResultDataDictionary<DefaultResultData>, enableConsoleLog: boolean = false) {\n    // If the result property is specified, inject it.\n    // If the previousResults exists (indicating we are in a loop),\n    // process the update property (nodeId or nodeId.propId).\n    Object.keys(this.data.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node?.isStaticNode) {\n        const update = node?.update;\n        if (update && previousResults) {\n          const result = this.getValueFromResults(update, previousResults);\n          this.injectValue(nodeId, result, update.nodeId);\n        }\n        if (enableConsoleLog) {\n          node.consoleLog();\n        }\n      }\n    });\n  }\n\n  constructor(\n    data: GraphData,\n    agentFunctionInfoDictionary: AgentFunctionInfoDictionary,\n    options: GraphOptions = {\n      taskManager: undefined,\n      agentFilters: [],\n      bypassAgentIds: [],\n      config: {},\n      graphLoader: undefined,\n    },\n  ) {\n    if (!data.version && !options.taskManager) {\n      console.warn(\"------------ missing version number\");\n    }\n    this.version = data.version ?? graphDataLatestVersion;\n    if (this.version < graphDataLatestVersion) {\n      console.warn(`------------ upgrade to ${graphDataLatestVersion}!`);\n    }\n    this.retryLimit = data.retry; // optional\n    this.graphId = URL.createObjectURL(new Blob()).slice(-36);\n    this.data = data;\n    this.agentFunctionInfoDictionary = agentFunctionInfoDictionary;\n    this.propFunctions = propFunctions;\n    this.taskManager = options.taskManager ?? new TaskManager(data.concurrency ?? defaultConcurrency);\n    this.agentFilters = options.agentFilters ?? [];\n    this.bypassAgentIds = options.bypassAgentIds ?? [];\n    this.config = options.config;\n    this.graphLoader = options.graphLoader;\n    this.loop = data.loop;\n    this.verbose = data.verbose === true;\n    this.onComplete = () => {\n      throw new Error(\"SOMETHING IS WRONG: onComplete is called without run()\");\n    };\n\n    validateGraphData(data, [...Object.keys(agentFunctionInfoDictionary), ...this.bypassAgentIds]);\n\n    this.nodes = this.createNodes(data);\n    this.initializeStaticNodes(true);\n  }\n\n  public getAgentFunctionInfo(agentId?: string) {\n    if (agentId && this.agentFunctionInfoDictionary[agentId]) {\n      return this.agentFunctionInfoDictionary[agentId];\n    }\n    if (agentId && this.bypassAgentIds.includes(agentId)) {\n      return {\n        agent: async () => {\n          return null;\n        },\n        inputs: null,\n        cacheType: undefined, // for node.getContext\n      };\n    }\n    // We are not supposed to hit this error because the validator will catch it.\n    throw new Error(\"No agent: \" + agentId);\n  }\n\n  public asString() {\n    return Object.values(this.nodes)\n      .map((node) => node.asString())\n      .join(\"\\n\");\n  }\n\n  // Public API\n  public results<T = DefaultResultData>(all: boolean): ResultDataDictionary<T> {\n    return Object.keys(this.nodes)\n      .filter((nodeId) => all || this.nodes[nodeId].isResult)\n      .reduce((results: ResultDataDictionary<T>, nodeId) => {\n        const node = this.nodes[nodeId];\n        if (node.result !== undefined) {\n          results[nodeId] = node.result as T;\n        }\n        return results;\n      }, {});\n  }\n\n  // Public API\n  public errors(): Record<string, Error> {\n    return Object.keys(this.nodes).reduce((errors: Record<string, Error>, nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node.isComputedNode) {\n        if (node.error !== undefined) {\n          errors[nodeId] = node.error;\n        }\n      }\n      return errors;\n    }, {});\n  }\n\n  private pushReadyNodesIntoQueue() {\n    // Nodes without pending data should run immediately.\n    Object.keys(this.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node.isComputedNode) {\n        this.pushQueueIfReady(node);\n      }\n    });\n  }\n\n  private pushQueueIfReady(node: ComputedNode) {\n    if (node.isReadyNode()) {\n      this.pushQueue(node);\n    }\n  }\n\n  public pushQueueIfReadyAndRunning(node: ComputedNode) {\n    if (this.isRunning()) {\n      this.pushQueueIfReady(node);\n    }\n  }\n\n  // for computed\n  public pushQueue(node: ComputedNode) {\n    node.beforeAddTask();\n\n    this.taskManager.addTask(node, this.graphId, (_node) => {\n      assert(node.nodeId === _node.nodeId, \"GraphAI.pushQueue node mismatch\");\n      node.execute();\n    });\n  }\n\n  // Public API\n  public async run<T = DefaultResultData>(all: boolean = false): Promise<ResultDataDictionary<T>> {\n    if (\n      Object.values(this.nodes)\n        .filter((node) => node.isStaticNode)\n        .some((node) => node.result === undefined && node.update === undefined)\n    ) {\n      throw new Error(\"Static node must have value. Set value or injectValue or set update\");\n    }\n    if (this.isRunning()) {\n      throw new Error(\"This GraphUI instance is already running\");\n    }\n\n    this.pushReadyNodesIntoQueue();\n\n    if (!this.isRunning()) {\n      console.warn(\"-- nothing to execute\");\n      return {};\n    }\n\n    return new Promise((resolve, reject) => {\n      this.onComplete = () => {\n        const errors = this.errors();\n        const nodeIds = Object.keys(errors);\n        if (nodeIds.length > 0) {\n          reject(errors[nodeIds[0]]);\n        } else {\n          resolve(this.results(all));\n        }\n      };\n    });\n  }\n\n  // Public only for testing\n  public isRunning() {\n    return this.taskManager.isRunning(this.graphId);\n  }\n\n  // callback from execute\n  public onExecutionComplete(node: ComputedNode) {\n    this.taskManager.onComplete(node);\n    if (this.isRunning() || this.processLoopIfNecessary()) {\n      return; // continue running\n    }\n    this.onComplete(); // Nothing to run. Finish it.\n  }\n\n  // Must be called only from onExecutionComplete righ after removeRunning\n  // Check if there is any running computed nodes.\n  // In case of no running computed note, start the another iteration if ncessary (loop)\n  private processLoopIfNecessary() {\n    this.repeatCount++;\n    const loop = this.loop;\n    if (!loop) {\n      return false;\n    }\n\n    // We need to update static nodes, before checking the condition\n    const previousResults = this.results(true); // results from previous loop\n    this.updateStaticNodes(previousResults);\n\n    if (loop.count === undefined || this.repeatCount < loop.count) {\n      if (loop.while) {\n        const source = parseNodeName(loop.while);\n        const value = this.getValueFromResults(source, this.results(true));\n        // NOTE: We treat an empty array as false.\n        if (!isLogicallyTrue(value)) {\n          return false; // while condition is not met\n        }\n      }\n      this.nodes = this.createNodes(this.data);\n      this.initializeStaticNodes();\n      this.updateStaticNodes(previousResults, true);\n\n      this.pushReadyNodesIntoQueue();\n      return true; // Indicating that we are going to continue.\n    }\n    return false;\n  }\n\n  public setLoopLog(log: TransactionLog) {\n    log.isLoop = !!this.loop;\n    log.repeatCount = this.repeatCount;\n  }\n\n  public appendLog(log: TransactionLog) {\n    this.logs.push(log);\n    this.onLogCallback(log, false);\n  }\n\n  public updateLog(log: TransactionLog) {\n    this.onLogCallback(log, true);\n  }\n\n  // Public API\n  public transactionLogs() {\n    return this.logs;\n  }\n\n  // Public API\n  public injectValue(nodeId: string, value: ResultData, injectFrom?: string): void {\n    const node = this.nodes[nodeId];\n    if (node && node.isStaticNode) {\n      node.injectValue(value, injectFrom);\n    } else {\n      throw new Error(`injectValue with Invalid nodeId, ${nodeId}`);\n    }\n  }\n\n  public resultsOf(inputs?: Array<any> | Record<string, any>, anyInput: boolean = false) {\n    const results = resultsOf(inputs ?? [], this.nodes, this.propFunctions);\n    if (anyInput) {\n      return cleanResult(results);\n    }\n    return results;\n  }\n  public resultOf(source: DataSource) {\n    return resultOf(source, this.nodes, this.propFunctions);\n  }\n}\n"],"names":["parseNodeName","inputNodeId","regex","match","value","parts","split","length","nodeId","propIds","slice","assert","condition","message","isWarn","Error","console","warn","isObject","x","isNull","data","strIntentionalError","defaultAgentInfo","name","samples","inputs","params","result","description","category","author","repository","license","objectToKeyArray","innerData","ret","Object","keys","forEach","key","push","tmp","debugResultKeyInner","Array","isArray","from","reduce","index","String","isLogicallyTrue","isNamedInputs","namedInputs","inputs2dataSources","map","inp","flat","values","input","templateMatch","matchAll","m","dataSourceNodeIds","sources","filter","source","NodeState","TransactionLog","constructor","this","state","Waiting","initForComputedNode","node","graph","agentId","getAgentId","appendLog","onInjected","injectFrom","isUpdating","endTime","Date","now","setLoopLog","updateLog","onComplete","localLog","resultKeys","objectKeys","join","log","beforeExecute","transactionId","retryCount","undefined","startTime","dataSources","inputsData","beforeAddTask","onError","errorMessage","onSkipped","Node","waitlist","Set","asString","onSetResult","waitingNodeId","waitingNode","nodes","isComputedNode","removePending","pushQueueIfReadyAndRunning","afterConsoleLog","after","JSON","stringify","ComputedNode","graphId","super","isSkip","isStaticNode","filterParams","passThrough","retryLimit","retry","timeout","isResult","priority","anyInput","pendings","includes","agent","agentFunction","async","nestedGraph","addPendingNode","graphLoader","if","ifSource","unless","unlessSource","defaultValue","add","isReadyNode","size","resultOf","Skipped","error","execute","onExecutionComplete","checkDataAvailability","resultsOf","some","Queued","clear","delete","isCurrentTransaction","executeTimeout","Executing","TimedOut","shouldApplyAgentFilter","agentFilter","agentIds","nodeIds","agentFilterHandler","context","next","innerContext","agentFilters","afterExecute","previousResults","prepareExecute","setTimeout","getAgentFunctionInfo","getContext","taskManager","prepareForNesting","onLogCallback","forNestedGraph","graphData","agents","agentFunctionInfoDictionary","graphOptions","bypassAgentIds","config","beforeConsoleLog","restoreAfterNesting","errorProcess","Completed","getResult","Failed","inputSchema","debugInfo","getDebugInfo","cacheType","r","verbose","version","before","StaticNode","update","injectValue","Injected","consoleLog","propFunctionRegex","propFunctions","propId","matchJoin","parse","Number","isNaN","trim","toLowerCase","toUpperCase","isFinite","innerGetDataFromSource","propFunction","parseInt","getNestedData","getDataFromSource","resultsOfInner","results","replaceAll","cleanResultInner","graphDataAttributeKeys","computedNodeAttributeKeys","staticNodeAttributeKeys","ValidationError","setPrototypeOf","prototype","validateGraphData","graphNodesValidator","loop","count","while","concurrency","isInteger","graphDataValidator","computedNodeIds","staticNodeIds","graphAgentIds","nodeData","nodeValidator","computedNodeValidator","has","agentValidator","computedNodeId","dataSourceValidator","sourceType","sourceNodeIds","sourceNodeId","staticNodeId","updateNodeId","cycle","possibles","possobleNodeId","running","pendingNodeId","runningQueue","relationValidator","TaskManager","taskQueue","runningNodes","dequeueTaskIfPossible","task","shift","callback","addTask","splice","isRunning","getStatus","queuedNodes","queue","graphDataLatestVersion","createNodes","_nodes","pending","getValueFromResults","initializeStaticNodes","enableConsoleLog","updateStaticNodes","options","logs","__log","__isUpdate","repeatCount","URL","createObjectURL","Blob","all","errors","pushReadyNodesIntoQueue","pushQueueIfReady","pushQueue","_node","run","Promise","resolve","reject","processLoopIfNecessary","isLoop","transactionLogs","cleanResult","mock","milliseconds"],"mappings":"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"}