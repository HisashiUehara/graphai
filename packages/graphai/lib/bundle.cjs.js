"use strict";const t=t=>{if("string"==typeof t){const e=/^:(.*)$/,s=t.match(e);if(!s)return{value:t};const n=s[1].split(".");return 1==n.length?{nodeId:n[0]}:{nodeId:n[0],propIds:n.slice(1)}}return{value:t}};function e(t,e,s=!1){if(!t){if(!s)throw new Error(e);console.warn("warn: "+e)}}const s=t=>null!==t&&"object"==typeof t,n=t=>null==t,i="Intentional Error for Debugging",r={name:"defaultAgentInfo",samples:[{inputs:[],params:{},result:{}}],description:"",category:[],author:"",repository:"",license:""},o=t=>{const e=[];return Object.keys(t).forEach((s=>{e.push([s]),Object.keys(t[s]).length>0&&o(t[s]).forEach((t=>{e.push([s,...t])}))})),e},a=t=>null==t||"string"==typeof t?{}:Array.isArray(t)?Array.from(t.keys()).reduce(((e,s)=>(e["$"+String(s)]=a(t[s]),e)),{}):Object.keys(t).reduce(((e,s)=>(e[s]=a(t[s]),e)),{}),h=t=>!!(Array.isArray(t)?0!==t.length:t),u=t=>s(t)&&!Array.isArray(t)&&Object.keys(t||{}).length>0,d=e=>{if(Array.isArray(e))return e.map((t=>d(t))).flat();if(s(e))return Object.values(e).map((t=>d(t))).flat();if("string"==typeof e){const t=[...e.matchAll(/\${(:[^}]+)}/g)].map((t=>t[1]));if(t.length>0)return d(t)}return t(e)},c=t=>t.filter((t=>t.nodeId)).map((t=>t.nodeId));var p;exports.NodeState=void 0,(p=exports.NodeState||(exports.NodeState={})).Waiting="waiting",p.Queued="queued",p.Executing="executing",p.ExecutingServer="executing-server",p.Failed="failed",p.TimedOut="timed-out",p.Completed="completed",p.Injected="injected",p.Skipped="skipped";class l{constructor(t){this.nodeId=t,this.state=exports.NodeState.Waiting}initForComputedNode(t,e){this.agentId=t.getAgentId(),this.params=t.params,e.appendLog(this)}onInjected(t,e,s){const n="endTime"in this;this.result=t.result,this.state=t.state,this.endTime=Date.now(),this.injectFrom=s,e.setLoopLog(this),n?e.updateLog(this):e.appendLog(this)}onComplete(t,e,s){var n,i;this.result=t.result,this.resultKeys=(n=this.agentId||"",i=t.result,o({[n]:a(i)}).map((t=>":"+t.join(".")))),this.state=t.state,this.endTime=Date.now(),e.setLoopLog(this),s.length>0&&(this.log=s),e.updateLog(this)}beforeExecute(t,e,s,n){this.state=t.state,this.retryCount=t.retryCount>0?t.retryCount:void 0,this.startTime=s,this.inputs=c(t.dataSources),this.inputsData=n.length>0?n:void 0,e.setLoopLog(this),e.appendLog(this)}beforeAddTask(t,e){this.state=t.state,e.setLoopLog(this),e.appendLog(this)}onError(t,e,s){this.state=t.state,this.errorMessage=s,this.endTime=Date.now(),e.setLoopLog(this),e.updateLog(this)}onSkipped(t,e){this.state=t.state,e.setLoopLog(this),e.updateLog(this)}}class g{constructor(t,e){this.waitlist=new Set,this.state=exports.NodeState.Waiting,this.result=void 0,this.nodeId=t,this.graph=e,this.log=new l(t),this.console={}}asString(){return`${this.nodeId}: ${this.state} ${[...this.waitlist]}`}onSetResult(){this.waitlist.forEach((t=>{const e=this.graph.nodes[t];e.isComputedNode&&(e.removePending(this.nodeId),this.graph.pushQueueIfReadyAndRunning(e))}))}afterConsoleLog(t){!0===this.console.after?console.log("string"==typeof t?t:JSON.stringify(t,null,2)):this.console.after&&console.log(this.console.after)}}class f extends g{constructor(n,i,r,o){if(super(i,o),this.retryCount=0,this.dataSources=[],this.isNamedInputs=!1,this.isStaticNode=!1,this.isComputedNode=!0,this.graphId=n,this.params=r.params??{},this.console=r.console??{},this.filterParams=r.filterParams??{},this.passThrough=r.passThrough,this.retryLimit=r.retry??o.retryLimit??0,this.timeout=r.timeout,this.isResult=r.isResult??!1,this.priority=r.priority??0,this.anyInput=r.anyInput??!1,this.inputs=r.inputs,this.isNamedInputs=s(r.inputs)&&!Array.isArray(r.inputs),this.dataSources=r.inputs?d(r.inputs).flat(10):[],r.inputs&&!this.isNamedInputs&&console.warn(`array inputs have been deprecated. nodeId: ${i}: see https://github.com/receptron/graphai/blob/main/docs/NamedInputs.md`),this.pendings=new Set(c(this.dataSources)),e(["function","string"].includes(typeof r.agent),"agent must be either string or function"),"string"==typeof r.agent)this.agentId=r.agent;else{const t=r.agent;this.agentFunction=this.isNamedInputs?async({namedInputs:e})=>t(e):async({inputs:e})=>t(...e)}r.graph&&(this.nestedGraph="string"==typeof r.graph?this.addPendingNode(r.graph):r.graph),r.graphLoader&&o.graphLoader&&(this.nestedGraph=o.graphLoader(r.graphLoader)),r.if&&(this.ifSource=this.addPendingNode(r.if)),r.unless&&(this.unlessSource=this.addPendingNode(r.unless)),this.dynamicParams=Object.keys(this.params).reduce(((s,n)=>{const i=t(this.params[n]);return i.nodeId&&(e(!this.anyInput,"Dynamic params are not supported with anyInput"),s[n]=i,this.pendings.add(i.nodeId)),s}),{}),this.log.initForComputedNode(this,o)}getAgentId(){return this.agentId??"__custom__function"}addPendingNode(s){const n=t(s);return e(!!n.nodeId,`Invalid data source ${s}`),this.pendings.add(n.nodeId),n}isReadyNode(){return this.state===exports.NodeState.Waiting&&0===this.pendings.size&&(!(this.ifSource&&!h(this.graph.resultOf(this.ifSource))||this.unlessSource&&h(this.graph.resultOf(this.unlessSource)))||(this.state=exports.NodeState.Skipped,this.log.onSkipped(this,this.graph),!1))}retry(t,e){this.state=t,this.log.onError(this,this.graph,e.message),this.retryCount<this.retryLimit?(this.retryCount++,this.execute()):(this.result=void 0,this.error=e,this.transactionId=void 0,this.graph.onExecutionComplete(this))}checkDataAvailability(){return Object.values(this.graph.resultsOf(this.inputs)).flat().some((t=>void 0!==t))}beforeAddTask(){this.state=exports.NodeState.Queued,this.log.beforeAddTask(this,this.graph)}removePending(t){this.anyInput?this.checkDataAvailability()&&this.pendings.clear():this.pendings.delete(t)}isCurrentTransaction(t){return this.transactionId===t}executeTimeout(t){this.state===exports.NodeState.Executing&&this.isCurrentTransaction(t)&&(console.warn(`-- timeout ${this.timeout} with ${this.nodeId}`),this.retry(exports.NodeState.TimedOut,Error("Timeout")))}shouldApplyAgentFilter(t){return!!(t.agentIds&&Array.isArray(t.agentIds)&&t.agentIds.length>0&&this.agentId&&t.agentIds.includes(this.agentId))||(!!(t.nodeIds&&Array.isArray(t.nodeIds)&&t.nodeIds.length>0&&t.nodeIds.includes(this.nodeId))||!t.agentIds&&!t.nodeIds)}agentFilterHandler(t,e){let s=0;const n=t=>{const i=this.graph.agentFilters[s++];return i?this.shouldApplyAgentFilter(i)?(i.filterParams&&(t.filterParams={...i.filterParams,...t.filterParams}),i.agent(t,n)):n(t):e(t)};return n(t)}async execute(){const t=this.graph.resultsOf(this.inputs,this.anyInput),e=Date.now();this.prepareExecute(e,Object.values(t)),this.timeout&&this.timeout>0&&setTimeout((()=>{this.executeTimeout(e)}),this.timeout);try{const s=this.agentFunction??this.graph.getAgentFunctionInfo(this.agentId).agent,n=[],i=this.getContext(t,n);this.nestedGraph&&(this.graph.taskManager.prepareForNesting(),i.taskManager=this.graph.taskManager,i.onLogCallback=this.graph.onLogCallback,"nodes"in this.nestedGraph?i.graphData=this.nestedGraph:i.graphData=this.graph.resultOf(this.nestedGraph),i.agents=this.graph.agentFunctionInfoDictionary,i.forNestedGraph={graphData:i.graphData,agents:i.agents,graphOptions:{agentFilters:this.graph.agentFilters,taskManager:this.graph.taskManager,bypassAgentIds:this.graph.bypassAgentIds,config:this.graph.config,graphLoader:this.graph.graphLoader}}),this.beforeConsoleLog(i);const r=await this.agentFilterHandler(i,s);if(this.afterConsoleLog(r),this.nestedGraph&&this.graph.taskManager.restoreAfterNesting(),!this.isCurrentTransaction(e))return void console.log(`-- transactionId mismatch with ${this.nodeId} (probably timeout)`);this.state=exports.NodeState.Completed,this.result=this.getResult(r),this.log.onComplete(this,this.graph,n),this.onSetResult(),this.graph.onExecutionComplete(this)}catch(s){this.errorProcess(s,e,t)}}prepareExecute(t,e){this.state=exports.NodeState.Executing,this.log.beforeExecute(this,this.graph,t,e),this.transactionId=t}errorProcess(t,e,s){t instanceof Error&&t.message!==i&&(console.error(`<-- NodeId: ${this.nodeId}, Agent: ${this.agentId}`),console.error({namedInputs:s}),console.error(t),console.error("--\x3e")),this.isCurrentTransaction(e)?t instanceof Error?this.retry(exports.NodeState.Failed,t):(console.error(`-- NodeId: ${this.nodeId}: Unknown error was caught`),this.retry(exports.NodeState.Failed,Error("Unknown"))):console.warn(`-- transactionId mismatch with ${this.nodeId} (not timeout)`)}getParams(){return Object.keys(this.dynamicParams).reduce(((t,e)=>{const s=this.graph.resultOf(this.dynamicParams[e]);return t[e]=s,t}),{...this.params})}getInputs(t){return Array.isArray(this.inputs)?(this.inputs??[]).map((e=>t[String(e)])).filter((t=>!this.anyInput||t)):[]}getContext(t,e){return{params:this.getParams(),inputs:this.getInputs(t),namedInputs:this.isNamedInputs?t:{},inputSchema:this.agentFunction?void 0:this.graph.getAgentFunctionInfo(this.agentId)?.inputs,debugInfo:this.getDebugInfo(),filterParams:this.filterParams,agentFilters:this.graph.agentFilters,config:this.graph.config,log:e}}getResult(t){if(t&&this.passThrough){if(s(t)&&!Array.isArray(t))return{...t,...this.passThrough};if(Array.isArray(t))return t.map((t=>s(t)&&!Array.isArray(t)?{...t,...this.passThrough}:t))}return t}getDebugInfo(){return{nodeId:this.nodeId,agentId:this.agentId,retry:this.retryCount,verbose:this.graph.verbose,version:this.graph.version,isResult:this.isResult}}beforeConsoleLog(t){!0===this.console.before?console.log(JSON.stringify(this.isNamedInputs?t.namedInputs:t.inputs,null,2)):this.console.before&&console.log(this.console.before)}}class y extends g{constructor(e,s,n){super(e,n),this.isStaticNode=!0,this.isComputedNode=!1,this.value=s.value,this.update=s.update?t(s.update):void 0,this.isResult=s.isResult??!1,this.console=s.console??{}}injectValue(t,e){this.state=exports.NodeState.Injected,this.result=t,this.log.onInjected(this,this.graph,e),this.onSetResult()}consoleLog(){this.afterConsoleLog(this.result)}}const m=/^[a-zA-Z]+\([^)]*\)$/,I=[(t,e)=>{if(Array.isArray(t)){if("length()"===e)return t.length;if("flat()"===e)return t.flat();if("toJSON()"===e)return JSON.stringify(t);if("isEmpty()"===e)return 0===t.length;const s=e.match(/^join\(([,-]?)\)$/);if(s&&Array.isArray(s))return t.join(s[1]??"")}},(t,e)=>{if(s(t)){if("keys()"===e)return Object.keys(t);if("values()"===e)return Object.values(t);if("toJSON()"===e)return JSON.stringify(t)}},(t,e)=>{if("string"==typeof t){if("codeBlock()"===e){const e=("\n"+t).match(/\n```[a-zA-z]*([\s\S]*?)\n```/);if(e)return e[1]}if("jsonParse()"===e)return JSON.parse(t);if("toNumber()"===e){const e=Number(t);if(!isNaN(e))return e}}},(t,e)=>{if(void 0!==t&&Number.isFinite(t)){if("toString()"===e)return String(t);const s=/^add\((-?\d+)\)$/,n=e.match(s);if(n)return Number(t)+Number(n[1])}},(t,e)=>{if("boolean"==typeof t&&"not()"===e)return!t}],w=(t,e,i)=>{if(!n(t)&&e&&e.length>0){const r=((t,e,i)=>{if(e.match(m))for(const s of i){const i=s(t,e);if(!n(i))return i}if(Array.isArray(t)){const s=/^\$(\d+)$/,n=e.match(s);if(n)return t[parseInt(n[1],10)];if("$last"===e)return t[t.length-1]}else if(s(t)&&e in t)return t[e]})(t,e[0],i);return void 0===r&&console.error(`prop: ${e.join(".")} is not hit`),e.length>1?w(r,e.slice(1),i):r}return t},b=(t,e,s=[])=>e.nodeId?w(t,e.propIds,s):e.value,N=(e,s,n)=>{if(Array.isArray(e))return e.map((t=>N(t,s,n)));if(u(e))return k(e,s,n);if("string"==typeof e){const t=[...e.matchAll(/\${(:[^}]+)}/g)].map((t=>t[1]));if(t.length>0){const i=N(t,s,n);return Array.from(t.keys()).reduce(((e,s)=>e.replaceAll("${"+t[s]+"}",i[s])),e)}}return v(t(e),s,n)},k=(t,e,s)=>Array.isArray(t)?t.reduce(((t,n)=>(t[n]=N(n,e,s),t)),{}):Object.keys(t).reduce(((n,i)=>{const r=t[i];return n[i]=u(r)?k(r,e,s):N(r,e,s),n}),{}),v=(t,e,s)=>{const{result:n}=t.nodeId?e[t.nodeId]:{result:void 0};return b(n,t,s)},A=t=>Array.isArray(t)?t.map((t=>A(t))).filter((t=>!n(t))):s(t)?Object.keys(t).reduce(((e,s)=>{const i=A(t[s]);return n(i)||(e[s]=i),e}),{}):t,S=["nodes","concurrency","agentId","loop","verbose","version"],L=["inputs","anyInput","params","retry","timeout","agent","graph","graphLoader","isResult","priority","if","unless","filterParams","console","passThrough"],j=["value","update","isResult","console"];class O extends Error{constructor(t){super(`[41m${t}[0m`),Object.setPrototypeOf(this,O.prototype)}}const C=(e,s)=>{(t=>{if(void 0===t.nodes)throw new O("Invalid Graph Data: no nodes");if("object"!=typeof t.nodes)throw new O("Invalid Graph Data: invalid nodes");if(Array.isArray(t.nodes))throw new O("Invalid Graph Data: nodes must be object");if(0===Object.keys(t.nodes).length)throw new O("Invalid Graph Data: nodes is empty");Object.keys(t).forEach((t=>{if(!S.includes(t))throw new O("Graph Data does not allow "+t)}))})(e),(t=>{if(t.loop){if(void 0===t.loop.count&&void 0===t.loop.while)throw new O("Loop: Either count or while is required in loop");if(void 0!==t.loop.count&&void 0!==t.loop.while)throw new O("Loop: Both count and while cannot be set")}if(void 0!==t.concurrency){if(!Number.isInteger(t.concurrency))throw new O("Concurrency must be an integer");if(t.concurrency<1)throw new O("Concurrency must be a positive integer")}})(e);const n=[],i=[],r=new Set;return Object.keys(e.nodes).forEach((t=>{const s=e.nodes[t],o="value"in s;(t=>{if(t.agent&&t.value)throw new O("Cannot set both agent and value");if(!("agent"in t)&&!("value"in t))throw new O("Either agent or value is required")})(s);const a=o?"":s.agent;var h;o&&(h=s,Object.keys(h).forEach((t=>{if(!j.includes(t))throw new O("Static node does not allow "+t)})),1)&&i.push(t),!o&&(t=>(Object.keys(t).forEach((t=>{if(!L.includes(t))throw new O("Computed node does not allow "+t)})),!0))(s)&&n.push(t)&&"string"==typeof a&&r.add(a)})),((t,e)=>{t.forEach((t=>{if(!e.has(t))throw new O("Invalid Agent : "+t+" is not in AgentFunctionInfoDictionary.")}))})(r,new Set(s)),((e,s,n)=>{const i=new Set(Object.keys(e.nodes)),r={},o={};n.forEach((t=>{const s=e.nodes[t];r[t]=new Set;const n=(e,s)=>{s.forEach((s=>{if(s){if(!i.has(s))throw new O(`${e} not match: NodeId ${t}, Inputs: ${s}`);void 0===o[s]&&(o[s]=new Set),r[t].add(s),o[s].add(t)}}))};"agent"in s&&s&&(s.inputs&&n("Inputs",c(d(s.inputs))),s.if&&n("If",c(d({if:s.if}))),s.unless&&n("Unless",c(d({unless:s.unless}))),s.graph&&"string"==typeof s?.graph&&n("Graph",c(d({graph:s.graph}))))})),s.forEach((s=>{const n=e.nodes[s];if("value"in n&&n.update){const e=n.update,r=t(e).nodeId;if(!r)throw new O("Update it a literal");if(!i.has(r))throw new O(`Update not match: NodeId ${s}, update: ${e}`)}}));const a=t=>{t.forEach((t=>{(o[t]||[]).forEach((e=>{r[e].delete(t)}))}));const e=[];return Object.keys(r).forEach((t=>{0===r[t].size&&(e.push(t),delete r[t])})),e};let h=a(s);if(0===h.length)throw new O("No Initial Runnning Node");do{h=a(h)}while(h.length>0);if(Object.keys(r).length>0)throw new O("Some nodes are not executed: "+Object.keys(r).join(", "))})(e,i,n),!0};class x{constructor(t){this.taskQueue=[],this.runningNodes=new Set,this.concurrency=t}dequeueTaskIfPossible(){if(this.runningNodes.size<this.concurrency){const t=this.taskQueue.shift();t&&(this.runningNodes.add(t.node),t.callback(t.node))}}addTask(t,s,n){const i=this.taskQueue.filter((e=>e.node.priority>=t.priority)).length;e(i<=this.taskQueue.length,"TaskManager.addTask: Something is really wrong."),this.taskQueue.splice(i,0,{node:t,graphId:s,callback:n}),this.dequeueTaskIfPossible()}isRunning(t){return[...this.runningNodes].filter((e=>e.graphId==t)).length>0||Array.from(this.taskQueue).filter((e=>e.graphId===t)).length>0}onComplete(t){e(this.runningNodes.has(t),`TaskManager.onComplete node(${t.nodeId}) is not in list`),this.runningNodes.delete(t),this.dequeueTaskIfPossible()}prepareForNesting(){this.concurrency++}restoreAfterNesting(){this.concurrency--}getStatus(t=!1){const e=Array.from(this.runningNodes).map((t=>t.nodeId)),s=this.taskQueue.map((t=>t.node.nodeId)),n=t?{runningNodes:e,queuedNodes:s}:{};return{concurrency:this.concurrency,queue:this.taskQueue.length,running:this.runningNodes.size,...n}}}const E=.5;exports.GraphAI=class{createNodes(t){const e=Object.keys(t.nodes).reduce(((e,s)=>{const n=t.nodes[s];if("value"in n)e[s]=new y(s,n,this);else{if(!("agent"in n))throw new Error("Unknown node type (neither value nor agent): "+s);e[s]=new f(this.graphId,s,n,this)}return e}),{});return Object.keys(e).forEach((t=>{const s=e[t];s.isComputedNode&&s.pendings.forEach((s=>{if(!e[s])throw new Error(`createNode: invalid input ${s} for node, ${t}`);e[s].waitlist.add(t)}))})),e}getValueFromResults(t,e){return b(t.nodeId?e[t.nodeId]:void 0,t,this.propFunctions)}initializeStaticNodes(t=!1){Object.keys(this.data.nodes).forEach((e=>{const s=this.nodes[e];if(s?.isStaticNode){const n=s?.value;void 0!==n&&this.injectValue(e,n,e),t&&s.consoleLog()}}))}updateStaticNodes(t,e=!1){Object.keys(this.data.nodes).forEach((s=>{const n=this.nodes[s];if(n?.isStaticNode){const i=n?.update;if(i&&t){const e=this.getValueFromResults(i,t);this.injectValue(s,e,i.nodeId)}e&&n.consoleLog()}}))}constructor(t,e,s={taskManager:void 0,agentFilters:[],bypassAgentIds:[],config:{},graphLoader:void 0}){this.logs=[],this.config={},this.onLogCallback=(t,e)=>{},this.repeatCount=0,t.version||s.taskManager||console.warn("------------ missing version number"),this.version=t.version??E,this.version<E&&console.warn("------------ upgrade to 0.5!"),this.retryLimit=t.retry,this.graphId=URL.createObjectURL(new Blob).slice(-36),this.data=t,this.agentFunctionInfoDictionary=e,this.propFunctions=I,this.taskManager=s.taskManager??new x(t.concurrency??8),this.agentFilters=s.agentFilters??[],this.bypassAgentIds=s.bypassAgentIds??[],this.config=s.config,this.graphLoader=s.graphLoader,this.loop=t.loop,this.verbose=!0===t.verbose,this.onComplete=()=>{throw new Error("SOMETHING IS WRONG: onComplete is called without run()")},C(t,[...Object.keys(e),...this.bypassAgentIds]),this.nodes=this.createNodes(t),this.initializeStaticNodes(!0)}getAgentFunctionInfo(t){if(t&&this.agentFunctionInfoDictionary[t])return this.agentFunctionInfoDictionary[t];if(t&&this.bypassAgentIds.includes(t))return{agent:async()=>null,inputs:null};throw new Error("No agent: "+t)}asString(){return Object.values(this.nodes).map((t=>t.asString())).join("\n")}results(t){return Object.keys(this.nodes).filter((e=>t||this.nodes[e].isResult)).reduce(((t,e)=>{const s=this.nodes[e];return void 0!==s.result&&(t[e]=s.result),t}),{})}errors(){return Object.keys(this.nodes).reduce(((t,e)=>{const s=this.nodes[e];return s.isComputedNode&&void 0!==s.error&&(t[e]=s.error),t}),{})}pushReadyNodesIntoQueue(){Object.keys(this.nodes).forEach((t=>{const e=this.nodes[t];e.isComputedNode&&this.pushQueueIfReady(e)}))}pushQueueIfReady(t){t.isReadyNode()&&this.pushQueue(t)}pushQueueIfReadyAndRunning(t){this.isRunning()&&this.pushQueueIfReady(t)}pushQueue(t){t.beforeAddTask(),this.taskManager.addTask(t,this.graphId,(s=>{e(t.nodeId===s.nodeId,"GraphAI.pushQueue node mismatch"),t.execute()}))}async run(t=!1){if(this.isRunning())throw new Error("This GraphUI instance is already running");return this.pushReadyNodesIntoQueue(),this.isRunning()?new Promise(((e,s)=>{this.onComplete=()=>{const n=this.errors(),i=Object.keys(n);i.length>0?s(n[i[0]]):e(this.results(t))}})):(console.warn("-- nothing to execute"),{})}isRunning(){return this.taskManager.isRunning(this.graphId)}onExecutionComplete(t){this.taskManager.onComplete(t),this.isRunning()||this.processLoopIfNecessary()||this.onComplete()}processLoopIfNecessary(){this.repeatCount++;const e=this.loop;if(!e)return!1;const s=this.results(!0);if(this.updateStaticNodes(s),void 0===e.count||this.repeatCount<e.count){if(e.while){const s=t(e.while),n=this.getValueFromResults(s,this.results(!0));if(!h(n))return!1}return this.nodes=this.createNodes(this.data),this.initializeStaticNodes(),this.updateStaticNodes(s,!0),this.pushReadyNodesIntoQueue(),!0}return!1}setLoopLog(t){t.isLoop=!!this.loop,t.repeatCount=this.repeatCount}appendLog(t){this.logs.push(t),this.onLogCallback(t,!1)}updateLog(t){this.onLogCallback(t,!0)}transactionLogs(){return this.logs}injectValue(t,e,s){const n=this.nodes[t];if(!n||!n.isStaticNode)throw new Error(`injectValue with Invalid nodeId, ${t}`);n.injectValue(e,s)}resultsOf(t,e=!1){const s=k(t??[],this.nodes,this.propFunctions);return e?(t=>Object.keys(t).reduce(((e,s)=>{const i=A(t[s]);return n(i)||(e[s]=i),e}),{}))(s):s}resultOf(t){return v(t,this.nodes,this.propFunctions)}},exports.ValidationError=O,exports.agentInfoWrapper=t=>({agent:t,mock:t,...r}),exports.assert=e,exports.defaultAgentInfo=r,exports.defaultConcurrency=8,exports.defaultTestContext={debugInfo:{nodeId:"test",retry:0,verbose:!0},params:{},filterParams:{},agents:{},log:[]},exports.graphDataLatestVersion=E,exports.inputs2dataSources=d,exports.isObject=s,exports.parseNodeName=t,exports.sleep=async t=>await new Promise((e=>setTimeout(e,t))),exports.strIntentionalError=i;
//# sourceMappingURL=bundle.cjs.js.map
