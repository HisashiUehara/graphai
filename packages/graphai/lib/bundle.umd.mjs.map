{"version":3,"file":"bundle.umd.mjs","sources":["../src/utils/utils.ts","../src/utils/nodeUtils.ts","../src/type.ts","../src/transaction_log.ts","../src/node.ts","../src/utils/prop_function.ts","../src/utils/data_source.ts","../src/utils/result.ts","../src/validators/common.ts","../src/validators/graph_data_validator.ts","../src/validators/nodeValidator.ts","../src/validators/static_node_validator.ts","../src/validators/computed_node_validator.ts","../src/validators/relation_validator.ts","../src/validators/agent_validator.ts","../src/validator.ts","../src/task_manager.ts","../src/graphai.ts"],"sourcesContent":["import { DataSource, AgentFunction, DefaultInputData } from \"@/type\";\n\nexport const sleep = async (milliseconds: number) => {\n  return await new Promise((resolve) => setTimeout(resolve, milliseconds));\n};\n\nexport const parseNodeName = (inputNodeId: any): DataSource => {\n  if (typeof inputNodeId === \"string\") {\n    const regex = /^:(.*)$/;\n    const match = inputNodeId.match(regex);\n    if (!match) {\n      return { value: inputNodeId }; // string literal\n    }\n    const parts = match[1].split(\".\");\n    if (parts.length == 1) {\n      return { nodeId: parts[0] };\n    }\n    return { nodeId: parts[0], propIds: parts.slice(1) };\n  }\n  return { value: inputNodeId }; // non-string literal\n};\n\nexport function assert(condition: boolean, message: string, isWarn: boolean = false): asserts condition {\n  if (!condition) {\n    if (!isWarn) {\n      throw new Error(message);\n    }\n    console.warn(\"warn: \" + message);\n  }\n}\n\nexport const isObject = (x: unknown) => {\n  return x !== null && typeof x === \"object\";\n};\n\nexport const isNull = (data: unknown) => {\n  return data === null || data === undefined;\n};\n\nexport const strIntentionalError = \"Intentional Error for Debugging\";\n\nexport const defaultAgentInfo = {\n  name: \"defaultAgentInfo\",\n  samples: [\n    {\n      inputs: [],\n      params: {},\n      result: {},\n    },\n  ],\n  description: \"\",\n  category: [],\n  author: \"\",\n  repository: \"\",\n  license: \"\",\n};\n\nexport const agentInfoWrapper = (agent: AgentFunction<any, any, any, any>) => {\n  return {\n    agent,\n    mock: agent,\n    ...defaultAgentInfo,\n  };\n};\n\nconst objectToKeyArray = (innerData: any) => {\n  const ret: string[][] = [];\n  Object.keys(innerData).forEach((key: string) => {\n    ret.push([key]);\n    if (Object.keys(innerData[key]).length > 0) {\n      objectToKeyArray(innerData[key]).forEach((tmp: string[]) => {\n        ret.push([key, ...tmp]);\n      });\n    }\n  });\n  return ret;\n};\n\nexport const debugResultKey = (agentId: string, result: any) => {\n  return objectToKeyArray({ [agentId]: debugResultKeyInner(result) }).map((objectKeys: string[]) => {\n    return \":\" + objectKeys.join(\".\");\n  });\n};\n\nconst debugResultKeyInner = (result: any) => {\n  if (result === null || result === undefined) {\n    return {};\n  }\n  if (typeof result === \"string\") {\n    return {};\n  }\n  if (Array.isArray(result)) {\n    return Array.from(result.keys()).reduce((tmp: Record<string, any>, index: number) => {\n      tmp[\"$\" + String(index)] = debugResultKeyInner(result[index]);\n      return tmp;\n    }, {});\n  }\n  return Object.keys(result).reduce((tmp: Record<string, any>, key: string) => {\n    tmp[key] = debugResultKeyInner(result[key]);\n    return tmp;\n  }, {});\n};\n\nexport const isLogicallyTrue = (value: any) => {\n  // Notice that empty aray is not true under GraphAI\n  if (Array.isArray(value) ? value.length === 0 : !value) {\n    return false;\n  }\n  return true;\n};\n\nexport const defaultTestContext = {\n  debugInfo: {\n    nodeId: \"test\",\n    retry: 0,\n    verbose: true,\n  },\n  params: {},\n  filterParams: {},\n  agents: {},\n  log: [],\n};\n\nexport const isNamedInputs = <NamedInput = DefaultInputData>(namedInputs: NamedInput) => {\n  return isObject(namedInputs) && !Array.isArray(namedInputs) && Object.keys(namedInputs || {}).length > 0;\n};\n","import { parseNodeName, isObject } from \"./utils\";\nimport { DataSource } from \"@/type\";\n\n// for dataSource\nexport const inputs2dataSources = (inputs: any): DataSource[] => {\n  if (Array.isArray(inputs)) {\n    return inputs.map((inp) => inputs2dataSources(inp)).flat();\n  }\n  if (isObject(inputs)) {\n    return Object.values(inputs)\n      .map((input) => inputs2dataSources(input))\n      .flat();\n  }\n  if (typeof inputs === \"string\") {\n    const templateMatch = [...inputs.matchAll(/\\${(:[^}]+)}/g)].map((m) => m[1]);\n    if (templateMatch.length > 0) {\n      return inputs2dataSources(templateMatch);\n    }\n  }\n\n  return parseNodeName(inputs) as any;\n};\n\nexport const dataSourceNodeIds = (sources: DataSource[]): string[] => {\n  return sources.filter((source: DataSource) => source.nodeId).map((source) => source.nodeId!);\n};\n","import type { TransactionLog } from \"@/transaction_log\";\nimport type { TaskManager } from \"@/task_manager\";\n\nexport enum NodeState {\n  Waiting = \"waiting\",\n  Queued = \"queued\",\n  Executing = \"executing\",\n  ExecutingServer = \"executing-server\",\n  Failed = \"failed\",\n  TimedOut = \"timed-out\",\n  Completed = \"completed\",\n  Injected = \"injected\",\n  Skipped = \"skipped\",\n}\n\nexport type DefaultResultData = Record<string, any> | string | number | boolean | Array<DefaultResultData>;\nexport type DefaultInputData = Record<string, any>;\nexport type ResultData<ResultType = DefaultResultData> = ResultType | undefined;\nexport type ResultDataDictionary<ResultType = DefaultResultData> = Record<string, ResultData<ResultType>>;\n\nexport type DefaultParamsType = Record<string, any>;\nexport type NodeDataParams<ParamsType = DefaultParamsType> = ParamsType; // Agent-specific parameters\n\nexport type PassThrough = Record<string, any>;\n\nexport type DataSource = {\n  nodeId?: string;\n  value?: any;\n  propIds?: string[];\n};\n\nexport type StaticNodeData = {\n  value: ResultData; // initial value for static node.\n  update?: string; // nodeId (+.propId) to get value after a loop\n  isResult?: boolean;\n  console?: Record<string, string | boolean>;\n};\nexport type AgentAnonymousFunction = (...params: any[]) => unknown;\n\nexport type AgentFilterParams = Record<string, any>;\n\nexport type GraphDataLoaderOption = { fileName: string; option?: any };\n\nexport type ComputedNodeData = {\n  agent: string | AgentAnonymousFunction;\n  inputs?: Array<any> | Record<string, any>;\n  anyInput?: boolean; // any input makes this node ready\n  params?: NodeDataParams;\n  filterParams?: AgentFilterParams; // agent filter\n  retry?: number;\n  timeout?: number; // msec\n  if?: string; // conditional execution\n  unless?: string; // conditional execution\n  graph?: GraphData | string;\n  graphLoader?: GraphDataLoaderOption;\n  isResult?: boolean;\n  priority?: number; // The default is 0.\n  passThrough?: PassThrough; // data that pass trough to result\n  console?: Record<string, string | boolean>;\n};\n\nexport type NodeData = StaticNodeData | ComputedNodeData;\n\nexport type LoopData = {\n  count?: number;\n  while?: string;\n};\n\nexport type GraphData = {\n  version?: number; // major version, 0.1, 0.2, ...\n  nodes: Record<string, NodeData>;\n  concurrency?: number;\n  loop?: LoopData;\n  verbose?: boolean;\n  retry?: number;\n  metadata?: any; // Stores information about GraphData. GraphAI itself is not used this data.\n};\n\nexport type GraphDataLoader = (loaderOption: GraphDataLoaderOption) => GraphData;\n\nexport type GraphOptions = {\n  agentFilters?: AgentFilterInfo[] | undefined;\n  taskManager?: TaskManager | undefined;\n  bypassAgentIds?: string[] | undefined;\n  config?: Record<string, unknown>;\n  graphLoader?: GraphDataLoader;\n};\n\nexport type AgentFunctionContext<ParamsType = DefaultParamsType, InputDataType = DefaultInputData, NamedInputDataType = DefaultInputData> = {\n  params: NodeDataParams<ParamsType>;\n  inputs: Array<InputDataType>;\n  inputSchema?: any;\n  namedInputs: NamedInputDataType;\n  debugInfo: {\n    verbose: boolean;\n    nodeId: string;\n    retry: number;\n    agentId?: string;\n    version?: number;\n    isResult?: boolean;\n  };\n  graphData?: GraphData; // nested graph\n  agents?: AgentFunctionInfoDictionary; // for nested graph\n  taskManager?: TaskManager; // for nested graph\n  onLogCallback?: (log: TransactionLog, isUpdate: boolean) => void;\n  filterParams: AgentFilterParams; // agent filter\n  agentFilters?: AgentFilterInfo[];\n  log?: TransactionLog[];\n  config?: Record<string, unknown>;\n};\n\nexport type AgentFunction<\n  ParamsType = DefaultParamsType,\n  ResultType = DefaultResultData,\n  InputDataType = DefaultInputData,\n  NamedInputDataType = DefaultInputData,\n> = (context: AgentFunctionContext<ParamsType, InputDataType, NamedInputDataType>) => Promise<ResultData<ResultType>>;\n\nexport type AgentFilterFunction<\n  ParamsType = DefaultParamsType,\n  ResultType = DefaultResultData,\n  InputDataType = DefaultInputData,\n  NamedInputDataType = DefaultInputData,\n> = (context: AgentFunctionContext<ParamsType, InputDataType, NamedInputDataType>, agent: AgentFunction) => Promise<ResultData<ResultType>>;\n\nexport type AgentFilterInfo = {\n  name: string;\n  agent: AgentFilterFunction;\n  agentIds?: string[];\n  nodeIds?: string[];\n  filterParams?: AgentFilterParams;\n};\n\nexport type AgentFunctionInfoSample = {\n  inputs: any;\n  params: DefaultParamsType;\n  result: any;\n  graph?: GraphData;\n};\n\nexport type AgentFunctionInfo = {\n  name: string;\n  agent: AgentFunction<any, any, any, any>;\n  mock: AgentFunction<any, any, any, any>;\n  inputs?: any;\n  output?: any;\n  outputFormat?: any;\n  params?: any;\n  samples: AgentFunctionInfoSample[];\n  description: string;\n  category: string[];\n  author: string;\n  repository: string;\n  license: string;\n\n  environmentVariables?: string[];\n  stream?: boolean;\n  apiKeys?: string[];\n  npms?: string[];\n};\n\nexport type AgentFunctionInfoDictionary = Record<string, AgentFunctionInfo>;\n\nexport type PropFunction = (result: ResultData, propId: string) => ResultData;\n","import { ResultData, NodeDataParams, NodeState } from \"@/type\";\nimport type { GraphAI } from \"@/graphai\";\nimport type { ComputedNode, StaticNode } from \"@/node\";\nimport { debugResultKey } from \"@/utils/utils\";\nimport { dataSourceNodeIds } from \"@/utils/nodeUtils\";\n\nexport class TransactionLog {\n  public nodeId: string;\n  public state: NodeState;\n  public startTime?: number;\n  public endTime?: number;\n  public retryCount?: number;\n  public agentId?: string;\n  public params?: NodeDataParams;\n  public inputs?: string[];\n  public inputsData?: Array<ResultData>;\n  public injectFrom?: string;\n  public errorMessage?: string;\n  public result?: ResultData;\n  public resultKeys?: string[];\n  public mapIndex?: number;\n  public isLoop?: boolean;\n  public repeatCount?: number;\n  public log?: TransactionLog[];\n  constructor(nodeId: string) {\n    this.nodeId = nodeId;\n    this.state = NodeState.Waiting;\n  }\n\n  public initForComputedNode(node: ComputedNode, graph: GraphAI) {\n    this.agentId = node.getAgentId();\n    this.params = node.params;\n    graph.appendLog(this);\n  }\n\n  public onInjected(node: StaticNode, graph: GraphAI, injectFrom?: string) {\n    const isUpdating = \"endTime\" in this;\n    this.result = node.result;\n    this.state = node.state;\n    this.endTime = Date.now();\n    this.injectFrom = injectFrom;\n    graph.setLoopLog(this);\n    // console.log(this)\n    if (isUpdating) {\n      graph.updateLog(this);\n    } else {\n      graph.appendLog(this);\n    }\n  }\n\n  public onComplete(node: ComputedNode, graph: GraphAI, localLog: TransactionLog[]) {\n    this.result = node.result;\n    this.resultKeys = debugResultKey(this.agentId || \"\", node.result);\n    this.state = node.state;\n    this.endTime = Date.now();\n    graph.setLoopLog(this);\n    if (localLog.length > 0) {\n      this.log = localLog;\n    }\n    graph.updateLog(this);\n  }\n\n  public beforeExecute(node: ComputedNode, graph: GraphAI, transactionId: number, inputs: ResultData[]) {\n    this.state = node.state;\n    this.retryCount = node.retryCount > 0 ? node.retryCount : undefined;\n    this.startTime = transactionId;\n    this.inputs = dataSourceNodeIds(node.dataSources);\n    this.inputsData = inputs.length > 0 ? inputs : undefined;\n    graph.setLoopLog(this);\n    graph.appendLog(this);\n  }\n\n  public beforeAddTask(node: ComputedNode, graph: GraphAI) {\n    this.state = node.state;\n    graph.setLoopLog(this);\n    graph.appendLog(this);\n  }\n\n  public onError(node: ComputedNode, graph: GraphAI, errorMessage: string) {\n    this.state = node.state;\n    this.errorMessage = errorMessage;\n    this.endTime = Date.now();\n    graph.setLoopLog(this);\n    graph.updateLog(this);\n  }\n\n  public onSkipped(node: ComputedNode, graph: GraphAI) {\n    this.state = node.state;\n    graph.setLoopLog(this);\n    graph.updateLog(this);\n  }\n}\n","import type { GraphAI, GraphData } from \"@/index\";\nimport { strIntentionalError } from \"@/utils/utils\";\nimport { inputs2dataSources, dataSourceNodeIds } from \"@/utils/nodeUtils\";\n\nimport {\n  NodeDataParams,\n  ResultData,\n  DataSource,\n  ComputedNodeData,\n  StaticNodeData,\n  NodeState,\n  AgentFunctionContext,\n  AgentFunction,\n  AgentFilterInfo,\n  AgentFilterParams,\n  DefaultParamsType,\n  DefaultInputData,\n  PassThrough,\n} from \"@/type\";\nimport { parseNodeName, assert, isLogicallyTrue, isObject } from \"@/utils/utils\";\nimport { TransactionLog } from \"@/transaction_log\";\n\nexport class Node {\n  public readonly nodeId: string;\n  public readonly waitlist = new Set<string>(); // List of nodes which need data from this node.\n  public state = NodeState.Waiting;\n  public result: ResultData | undefined = undefined;\n\n  protected graph: GraphAI;\n  protected log: TransactionLog;\n  protected console: Record<string, string | boolean>; // console output option (before and/or after)\n\n  constructor(nodeId: string, graph: GraphAI) {\n    this.nodeId = nodeId;\n    this.graph = graph;\n    this.log = new TransactionLog(nodeId);\n    this.console = {};\n  }\n\n  public asString() {\n    return `${this.nodeId}: ${this.state} ${[...this.waitlist]}`;\n  }\n\n  // This method is called either as the result of computation (computed node) or\n  // injection (static node).\n  protected onSetResult() {\n    this.waitlist.forEach((waitingNodeId) => {\n      const waitingNode = this.graph.nodes[waitingNodeId];\n      if (waitingNode.isComputedNode) {\n        waitingNode.removePending(this.nodeId);\n        this.graph.pushQueueIfReadyAndRunning(waitingNode);\n      }\n    });\n  }\n\n  protected afterConsoleLog(result: ResultData) {\n    if (this.console.after === true) {\n      console.log(typeof result === \"string\" ? result : JSON.stringify(result, null, 2));\n    } else if (this.console.after) {\n      console.log(this.console.after);\n    }\n  }\n}\n\nexport class ComputedNode extends Node {\n  public readonly graphId: string;\n  public readonly isResult: boolean;\n  public readonly params: NodeDataParams; // Agent-specific parameters\n  private readonly filterParams: AgentFilterParams;\n  private readonly dynamicParams: Record<string, DataSource>;\n  public readonly nestedGraph?: GraphData | DataSource;\n  public readonly retryLimit: number;\n  public retryCount: number = 0;\n  private readonly agentId?: string;\n  private readonly agentFunction?: AgentFunction<any, any, any, any>;\n  public readonly timeout?: number; // msec\n  public readonly priority: number;\n  public error?: Error;\n  public transactionId: undefined | number; // To reject callbacks from timed-out transactions\n  private readonly passThrough?: PassThrough;\n\n  public readonly anyInput: boolean; // any input makes this node ready\n  public dataSources: DataSource[] = []; // no longer needed. This is for transaction log.\n  private inputs?: Array<any> | Record<string, any>;\n  public isNamedInputs: boolean = false;\n  public pendings: Set<string>; // List of nodes this node is waiting data from.\n  private ifSource?: DataSource; // conditional execution\n  private unlessSource?: DataSource; // conditional execution\n\n  public readonly isStaticNode = false;\n  public readonly isComputedNode = true;\n\n  constructor(graphId: string, nodeId: string, data: ComputedNodeData, graph: GraphAI) {\n    super(nodeId, graph);\n    this.graphId = graphId;\n    this.params = data.params ?? {};\n    this.console = data.console ?? {};\n    this.filterParams = data.filterParams ?? {};\n    this.passThrough = data.passThrough;\n    this.retryLimit = data.retry ?? graph.retryLimit ?? 0;\n    this.timeout = data.timeout;\n    this.isResult = data.isResult ?? false;\n    this.priority = data.priority ?? 0;\n\n    this.anyInput = data.anyInput ?? false;\n    this.inputs = data.inputs;\n    this.isNamedInputs = isObject(data.inputs) && !Array.isArray(data.inputs);\n    this.dataSources = data.inputs ? inputs2dataSources(data.inputs).flat(10) : [];\n    if (data.inputs && !this.isNamedInputs) {\n      console.warn(`array inputs have been deprecated. nodeId: ${nodeId}: see https://github.com/receptron/graphai/blob/main/docs/NamedInputs.md`);\n    }\n\n    this.pendings = new Set(dataSourceNodeIds(this.dataSources));\n    assert([\"function\", \"string\"].includes(typeof data.agent), \"agent must be either string or function\");\n    if (typeof data.agent === \"string\") {\n      this.agentId = data.agent;\n    } else {\n      const agent = data.agent;\n      this.agentFunction = this.isNamedInputs ? async ({ namedInputs }) => agent(namedInputs) : async ({ inputs }) => agent(...inputs);\n    }\n    if (data.graph) {\n      this.nestedGraph = typeof data.graph === \"string\" ? this.addPendingNode(data.graph) : data.graph;\n    }\n    if (data.graphLoader && graph.graphLoader) {\n      this.nestedGraph = graph.graphLoader(data.graphLoader);\n    }\n    if (data.if) {\n      this.ifSource = this.addPendingNode(data.if);\n    }\n    if (data.unless) {\n      this.unlessSource = this.addPendingNode(data.unless);\n    }\n    this.dynamicParams = Object.keys(this.params).reduce((tmp: Record<string, DataSource>, key) => {\n      const dataSource = parseNodeName(this.params[key]);\n      if (dataSource.nodeId) {\n        assert(!this.anyInput, \"Dynamic params are not supported with anyInput\");\n        tmp[key] = dataSource;\n        this.pendings.add(dataSource.nodeId);\n      }\n      return tmp;\n    }, {});\n\n    this.log.initForComputedNode(this, graph);\n  }\n\n  public getAgentId() {\n    return this.agentId ?? \"__custom__function\"; // only for display purpose in the log.\n  }\n\n  private addPendingNode(nodeId: string) {\n    const source = parseNodeName(nodeId);\n    assert(!!source.nodeId, `Invalid data source ${nodeId}`);\n    this.pendings.add(source.nodeId);\n    return source;\n  }\n\n  public isReadyNode() {\n    if (this.state !== NodeState.Waiting || this.pendings.size !== 0) {\n      return false;\n    }\n    if (\n      (this.ifSource && !isLogicallyTrue(this.graph.resultOf(this.ifSource))) ||\n      (this.unlessSource && isLogicallyTrue(this.graph.resultOf(this.unlessSource)))\n    ) {\n      this.state = NodeState.Skipped;\n      this.log.onSkipped(this, this.graph);\n      return false;\n    }\n    return true;\n  }\n\n  // This private method (only called while executing execute()) performs\n  // the \"retry\" if specified. The transaction log must be updated before\n  // callling this method.\n  private retry(state: NodeState, error: Error) {\n    this.state = state; // this.execute() will update to NodeState.Executing\n    this.log.onError(this, this.graph, error.message);\n\n    if (this.retryCount < this.retryLimit) {\n      this.retryCount++;\n      this.execute();\n    } else {\n      this.result = undefined;\n      this.error = error;\n      this.transactionId = undefined; // This is necessary for timeout case\n      this.graph.onExecutionComplete(this);\n    }\n  }\n\n  private checkDataAvailability() {\n    return Object.values(this.graph.resultsOf(this.inputs))\n      .flat()\n      .some((result) => result !== undefined);\n  }\n\n  // This method is called right before the Graph add this node to the task manager.\n  public beforeAddTask() {\n    this.state = NodeState.Queued;\n    this.log.beforeAddTask(this, this.graph);\n  }\n\n  // This method is called when the data became available on one of nodes,\n  // which this node needs data from.\n  public removePending(nodeId: string) {\n    if (this.anyInput) {\n      if (this.checkDataAvailability()) {\n        this.pendings.clear();\n      }\n    } else {\n      this.pendings.delete(nodeId);\n    }\n  }\n\n  private isCurrentTransaction(transactionId: number) {\n    return this.transactionId === transactionId;\n  }\n\n  // This private method (called only fro execute) checks if the callback from\n  // the timer came before the completion of agent function call, record it\n  // and attempt to retry (if specified).\n  private executeTimeout(transactionId: number) {\n    if (this.state === NodeState.Executing && this.isCurrentTransaction(transactionId)) {\n      console.warn(`-- timeout ${this.timeout} with ${this.nodeId}`);\n      this.retry(NodeState.TimedOut, Error(\"Timeout\"));\n    }\n  }\n\n  // Check if we need to apply this filter to this node or not.\n  private shouldApplyAgentFilter(agentFilter: AgentFilterInfo) {\n    if (agentFilter.agentIds && Array.isArray(agentFilter.agentIds) && agentFilter.agentIds.length > 0) {\n      if (this.agentId && agentFilter.agentIds.includes(this.agentId)) {\n        return true;\n      }\n    }\n    if (agentFilter.nodeIds && Array.isArray(agentFilter.nodeIds) && agentFilter.nodeIds.length > 0) {\n      if (agentFilter.nodeIds.includes(this.nodeId)) {\n        return true;\n      }\n    }\n    return !agentFilter.agentIds && !agentFilter.nodeIds;\n  }\n\n  private agentFilterHandler(context: AgentFunctionContext, agentFunction: AgentFunction): Promise<ResultData> {\n    let index = 0;\n\n    const next = (innerContext: AgentFunctionContext): Promise<ResultData> => {\n      const agentFilter = this.graph.agentFilters[index++];\n      if (agentFilter) {\n        if (this.shouldApplyAgentFilter(agentFilter)) {\n          if (agentFilter.filterParams) {\n            innerContext.filterParams = { ...agentFilter.filterParams, ...innerContext.filterParams };\n          }\n          return agentFilter.agent(innerContext, next);\n        }\n        return next(innerContext);\n      }\n      return agentFunction(innerContext);\n    };\n\n    return next(context);\n  }\n\n  // This method is called when this computed node became ready to run.\n  // It asynchronously calls the associated with agent function and set the result,\n  // then it removes itself from the \"running node\" list of the graph.\n  // Notice that setting the result of this node may make other nodes ready to run.\n  public async execute() {\n    const previousResults = this.graph.resultsOf(this.inputs, this.anyInput);\n    const transactionId = Date.now();\n    this.prepareExecute(transactionId, Object.values(previousResults));\n\n    if (this.timeout && this.timeout > 0) {\n      setTimeout(() => {\n        this.executeTimeout(transactionId);\n      }, this.timeout);\n    }\n\n    try {\n      const agentFunction = this.agentFunction ?? this.graph.getAgentFunctionInfo(this.agentId).agent;\n      const localLog: TransactionLog[] = [];\n      const context = this.getContext(previousResults, localLog);\n\n      // NOTE: We use the existence of graph object in the agent-specific params to determine\n      // if this is a nested agent or not.\n      if (this.nestedGraph) {\n        this.graph.taskManager.prepareForNesting();\n        context.taskManager = this.graph.taskManager;\n        context.onLogCallback = this.graph.onLogCallback;\n        if (\"nodes\" in this.nestedGraph) {\n          context.graphData = this.nestedGraph;\n        } else {\n          context.graphData = this.graph.resultOf(this.nestedGraph) as GraphData; // HACK: compiler work-around\n        }\n        context.agents = this.graph.agentFunctionInfoDictionary;\n      }\n\n      this.beforeConsoleLog(context);\n      const result = await this.agentFilterHandler(context as AgentFunctionContext, agentFunction);\n      this.afterConsoleLog(result);\n\n      if (this.nestedGraph) {\n        this.graph.taskManager.restoreAfterNesting();\n      }\n\n      if (!this.isCurrentTransaction(transactionId)) {\n        // This condition happens when the agent function returns\n        // after the timeout (either retried or not).\n        console.log(`-- transactionId mismatch with ${this.nodeId} (probably timeout)`);\n        return;\n      }\n\n      this.state = NodeState.Completed;\n      this.result = this.getResult(result);\n      this.log.onComplete(this, this.graph, localLog);\n\n      this.onSetResult();\n\n      this.graph.onExecutionComplete(this);\n    } catch (error) {\n      this.errorProcess(error, transactionId, previousResults);\n    }\n  }\n\n  // This private method (called only by execute()) prepares the ComputedNode object\n  // for execution, and create a new transaction to record it.\n  private prepareExecute(transactionId: number, inputs: Array<ResultData>) {\n    this.state = NodeState.Executing;\n    this.log.beforeExecute(this, this.graph, transactionId, inputs);\n    this.transactionId = transactionId;\n  }\n\n  // This private method (called only by execute) processes an error received from\n  // the agent function. It records the error in the transaction log and handles\n  // the retry if specified.\n  private errorProcess(error: unknown, transactionId: number, namedInputs: DefaultInputData) {\n    if (error instanceof Error && error.message !== strIntentionalError) {\n      console.error(`<-- NodeId: ${this.nodeId}, Agent: ${this.agentId}`);\n      console.error({ namedInputs });\n      console.error(error);\n      console.error(\"-->\");\n    }\n    if (!this.isCurrentTransaction(transactionId)) {\n      console.warn(`-- transactionId mismatch with ${this.nodeId} (not timeout)`);\n      return;\n    }\n\n    if (error instanceof Error) {\n      this.retry(NodeState.Failed, error);\n    } else {\n      console.error(`-- NodeId: ${this.nodeId}: Unknown error was caught`);\n      this.retry(NodeState.Failed, Error(\"Unknown\"));\n    }\n  }\n\n  private getParams() {\n    return Object.keys(this.dynamicParams).reduce(\n      (tmp, key) => {\n        const result = this.graph.resultOf(this.dynamicParams[key]);\n        tmp[key] = result;\n        return tmp;\n      },\n      { ...this.params },\n    );\n  }\n  private getInputs(previousResults: Record<string, ResultData | undefined>) {\n    if (Array.isArray(this.inputs)) {\n      return (this.inputs ?? []).map((key) => previousResults[String(key)]).filter((a) => !this.anyInput || a);\n    }\n    return [];\n  }\n\n  private getContext(previousResults: Record<string, ResultData | undefined>, localLog: TransactionLog[]) {\n    const context: AgentFunctionContext<DefaultParamsType, DefaultInputData | string | number | boolean | undefined> = {\n      params: this.getParams(),\n      inputs: this.getInputs(previousResults),\n      namedInputs: this.isNamedInputs ? previousResults : {},\n      inputSchema: this.agentFunction ? undefined : this.graph.getAgentFunctionInfo(this.agentId)?.inputs,\n      debugInfo: this.getDebugInfo(),\n      filterParams: this.filterParams,\n      agentFilters: this.graph.agentFilters,\n      config: this.graph.config,\n      log: localLog,\n    };\n    return context;\n  }\n\n  private getResult(result: ResultData) {\n    if (result && this.passThrough) {\n      if (isObject(result) && !Array.isArray(result)) {\n        return { ...result, ...this.passThrough };\n      } else if (Array.isArray(result)) {\n        return result.map((r) => (isObject(r) && !Array.isArray(r) ? { ...r, ...this.passThrough } : r));\n      }\n    }\n    return result;\n  }\n\n  private getDebugInfo() {\n    return {\n      nodeId: this.nodeId,\n      agentId: this.agentId,\n      retry: this.retryCount,\n      verbose: this.graph.verbose,\n      version: this.graph.version,\n      isResult: this.isResult,\n    };\n  }\n\n  private beforeConsoleLog(context: AgentFunctionContext<DefaultParamsType, string | number | boolean | DefaultInputData | undefined>) {\n    if (this.console.before === true) {\n      console.log(JSON.stringify(this.isNamedInputs ? context.namedInputs : context.inputs, null, 2));\n    } else if (this.console.before) {\n      console.log(this.console.before);\n    }\n  }\n}\n\nexport class StaticNode extends Node {\n  public value?: ResultData;\n  public readonly update?: DataSource;\n  public readonly isResult: boolean;\n  public readonly isStaticNode = true;\n  public readonly isComputedNode = false;\n\n  constructor(nodeId: string, data: StaticNodeData, graph: GraphAI) {\n    super(nodeId, graph);\n    this.value = data.value;\n    this.update = data.update ? parseNodeName(data.update) : undefined;\n    this.isResult = data.isResult ?? false;\n    this.console = data.console ?? {};\n  }\n\n  public injectValue(value: ResultData, injectFrom?: string) {\n    this.state = NodeState.Injected;\n    this.result = value;\n    this.log.onInjected(this, this.graph, injectFrom);\n    this.onSetResult();\n  }\n\n  public consoleLog() {\n    this.afterConsoleLog(this.result);\n  }\n}\n\nexport type GraphNodes = Record<string, ComputedNode | StaticNode>;\n","import { PropFunction } from \"@/type\";\nimport { isObject } from \"./utils\";\n\nexport const propFunctionRegex = /^[a-zA-Z]+\\([^)]*\\)$/;\n\nconst propArrayFunction: PropFunction = (result, propId) => {\n  if (Array.isArray(result)) {\n    if (propId === \"length()\") {\n      return result.length;\n    }\n    if (propId === \"flat()\") {\n      return result.flat();\n    }\n    if (propId === \"toJSON()\") {\n      return JSON.stringify(result);\n    }\n    if (propId === \"isEmpty()\") {\n      return result.length === 0;\n    }\n    // array join\n    const matchJoin = propId.match(/^join\\(([,-]?)\\)$/);\n    if (matchJoin && Array.isArray(matchJoin)) {\n      return result.join(matchJoin[1] ?? \"\");\n    }\n  }\n  return undefined;\n};\n\nconst propObjectFunction: PropFunction = (result, propId) => {\n  if (isObject(result)) {\n    if (propId === \"keys()\") {\n      return Object.keys(result);\n    }\n    if (propId === \"values()\") {\n      return Object.values(result);\n    }\n    if (propId === \"toJSON()\") {\n      return JSON.stringify(result);\n    }\n  }\n  return undefined;\n};\n\nconst propStringFunction: PropFunction = (result, propId) => {\n  if (typeof result === \"string\") {\n    if (propId === \"codeBlock()\") {\n      const match = (\"\\n\" + result).match(/\\n```[a-zA-z]*([\\s\\S]*?)\\n```/);\n      if (match) {\n        return match[1];\n      }\n    }\n    if (propId === \"jsonParse()\") {\n      return JSON.parse(result);\n    }\n    if (propId === \"toNumber()\") {\n      const ret = Number(result);\n      if (!isNaN(ret)) {\n        return ret;\n      }\n    }\n  }\n  return undefined;\n};\nconst propNumberFunction: PropFunction = (result, propId) => {\n  if (result !== undefined && Number.isFinite(result)) {\n    if (propId === \"toString()\") {\n      return String(result);\n    }\n    const regex = /^add\\((-?\\d+)\\)$/;\n    const match = propId.match(regex);\n    if (match) {\n      return Number(result) + Number(match[1]);\n    }\n  }\n  return undefined;\n};\nconst propBooleanFunction: PropFunction = (result, propId) => {\n  if (typeof result === \"boolean\") {\n    if (propId === \"not()\") {\n      return !result;\n    }\n  }\n  return undefined;\n};\n\nexport const propFunctions = [propArrayFunction, propObjectFunction, propStringFunction, propNumberFunction, propBooleanFunction];\n","import { ResultData, DataSource, PropFunction } from \"@/type\";\nimport { isObject, isNull } from \"./utils\";\nimport { propFunctionRegex } from \"./prop_function\";\n\nconst getNestedData = (result: ResultData, propId: string, propFunctions: PropFunction[]) => {\n  const match = propId.match(propFunctionRegex);\n  if (match) {\n    for (const propFunction of propFunctions) {\n      const ret = propFunction(result, propId);\n      if (!isNull(ret)) {\n        return ret;\n      }\n    }\n  }\n\n  // for array.\n  if (Array.isArray(result)) {\n    // $0, $1. array value.\n    const regex = /^\\$(\\d+)$/;\n    const match = propId.match(regex);\n    if (match) {\n      const index = parseInt(match[1], 10);\n      return result[index];\n    }\n    if (propId === \"$last\") {\n      return result[result.length - 1];\n    }\n  } else if (isObject(result)) {\n    if (propId in result) {\n      return result[propId];\n    }\n  }\n  return undefined;\n};\n\nconst innerGetDataFromSource = (result: ResultData, propIds: string[] | undefined, propFunctions: PropFunction[]): ResultData | undefined => {\n  if (!isNull(result) && propIds && propIds.length > 0) {\n    const propId = propIds[0];\n    const ret = getNestedData(result, propId, propFunctions);\n    if (ret === undefined) {\n      console.error(`prop: ${propIds.join(\".\")} is not hit`);\n    }\n    if (propIds.length > 1) {\n      return innerGetDataFromSource(ret, propIds.slice(1), propFunctions);\n    }\n    return ret;\n  }\n  return result;\n};\n\nexport const getDataFromSource = (result: ResultData | undefined, source: DataSource, propFunctions: PropFunction[] = []): ResultData | undefined => {\n  if (!source.nodeId) {\n    return source.value;\n  }\n  return innerGetDataFromSource(result, source.propIds, propFunctions);\n};\n","import { DataSource, ResultData, PropFunction } from \"@/type\";\n\nimport { GraphNodes } from \"@/node\";\n\nimport { parseNodeName, isNamedInputs, isObject, isNull } from \"@/utils/utils\";\nimport { getDataFromSource } from \"@/utils/data_source\";\n\nconst resultsOfInner = (input: any, nodes: GraphNodes, propFunctions: PropFunction[]): ResultData => {\n  if (Array.isArray(input)) {\n    return input.map((inp) => resultsOfInner(inp, nodes, propFunctions));\n  }\n  if (isNamedInputs(input)) {\n    return resultsOf(input, nodes, propFunctions);\n  }\n  if (typeof input === \"string\") {\n    const templateMatch = [...input.matchAll(/\\${(:[^}]+)}/g)].map((m) => m[1]);\n    if (templateMatch.length > 0) {\n      const results = resultsOfInner(templateMatch, nodes, propFunctions);\n      return Array.from(templateMatch.keys()).reduce((tmp, key) => {\n        return tmp.replaceAll(\"${\" + templateMatch[key] + \"}\", (results as any)[key]);\n      }, input);\n    }\n  }\n  return resultOf(parseNodeName(input), nodes, propFunctions);\n};\n\nexport const resultsOf = (inputs: Record<string, any> | Array<string>, nodes: GraphNodes, propFunctions: PropFunction[]) => {\n  // for inputs. TODO remove if array input is not supported\n  if (Array.isArray(inputs)) {\n    return inputs.reduce((tmp: Record<string, ResultData>, key) => {\n      tmp[key] = resultsOfInner(key, nodes, propFunctions);\n      return tmp;\n    }, {});\n  }\n  return Object.keys(inputs).reduce((tmp: Record<string, ResultData>, key) => {\n    const input = inputs[key];\n    tmp[key] = isNamedInputs(input) ? resultsOf(input, nodes, propFunctions) : resultsOfInner(input, nodes, propFunctions);\n    return tmp;\n  }, {});\n};\n\nexport const resultOf = (source: DataSource, nodes: GraphNodes, propFunctions: PropFunction[]) => {\n  const { result } = source.nodeId ? nodes[source.nodeId] : { result: undefined };\n  return getDataFromSource(result, source, propFunctions);\n};\n\n// clean up object for anyInput\nexport const cleanResultInner = (results: ResultData): ResultData | null => {\n  if (Array.isArray(results)) {\n    return results.map((result: ResultData) => cleanResultInner(result)).filter((result) => !isNull(result));\n  }\n\n  if (isObject(results)) {\n    return Object.keys(results).reduce((tmp: Record<string, ResultData>, key: string) => {\n      const value = cleanResultInner(results[key]);\n      if (!isNull(value)) {\n        tmp[key] = value;\n      }\n      return tmp;\n    }, {});\n  }\n\n  return results;\n};\n\nexport const cleanResult = (results: Record<string, ResultData | undefined>) => {\n  return Object.keys(results).reduce((tmp: Record<string, ResultData | undefined>, key: string) => {\n    const value = cleanResultInner(results[key]);\n    if (!isNull(value)) {\n      tmp[key] = value;\n    }\n    return tmp;\n  }, {});\n};\n","export const graphDataAttributeKeys = [\"nodes\", \"concurrency\", \"agentId\", \"loop\", \"verbose\", \"version\"];\n\nexport const computedNodeAttributeKeys = [\n  \"inputs\",\n  \"anyInput\",\n  \"params\",\n  \"retry\",\n  \"timeout\",\n  \"agent\",\n  \"graph\",\n  \"graphLoader\",\n  \"isResult\",\n  \"priority\",\n  \"if\",\n  \"unless\",\n  \"filterParams\",\n  \"console\",\n  \"passThrough\",\n];\nexport const staticNodeAttributeKeys = [\"value\", \"update\", \"isResult\", \"console\"];\n\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(`\\x1b[41m${message}\\x1b[0m`); // Pass the message to the base Error class\n\n    // Set the prototype explicitly to ensure correct prototype chain\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n","import { GraphData } from \"@/type\";\nimport { graphDataAttributeKeys, ValidationError } from \"@/validators/common\";\n\nexport const graphNodesValidator = (data: GraphData) => {\n  if (data.nodes === undefined) {\n    throw new ValidationError(\"Invalid Graph Data: no nodes\");\n  }\n  if (typeof data.nodes !== \"object\") {\n    throw new ValidationError(\"Invalid Graph Data: invalid nodes\");\n  }\n  if (Array.isArray(data.nodes)) {\n    throw new ValidationError(\"Invalid Graph Data: nodes must be object\");\n  }\n  if (Object.keys(data.nodes).length === 0) {\n    throw new ValidationError(\"Invalid Graph Data: nodes is empty\");\n  }\n  Object.keys(data).forEach((key) => {\n    if (!graphDataAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Graph Data does not allow \" + key);\n    }\n  });\n};\nexport const graphDataValidator = (data: GraphData) => {\n  if (data.loop) {\n    if (data.loop.count === undefined && data.loop.while === undefined) {\n      throw new ValidationError(\"Loop: Either count or while is required in loop\");\n    }\n    if (data.loop.count !== undefined && data.loop.while !== undefined) {\n      throw new ValidationError(\"Loop: Both count and while cannot be set\");\n    }\n  }\n  if (data.concurrency !== undefined) {\n    if (!Number.isInteger(data.concurrency)) {\n      throw new ValidationError(\"Concurrency must be an integer\");\n    }\n    if (data.concurrency < 1) {\n      throw new ValidationError(\"Concurrency must be a positive integer\");\n    }\n  }\n};\n","import { NodeData, StaticNodeData, ComputedNodeData } from \"@/type\";\nimport { ValidationError } from \"@/validators/common\";\n\nexport const nodeValidator = (nodeData: NodeData) => {\n  if ((nodeData as ComputedNodeData).agent && (nodeData as StaticNodeData).value) {\n    throw new ValidationError(\"Cannot set both agent and value\");\n  }\n  if (!(\"agent\" in nodeData) && !(\"value\" in nodeData)) {\n    throw new ValidationError(\"Either agent or value is required\");\n  }\n  return true;\n};\n","import { StaticNodeData } from \"@/type\";\nimport { staticNodeAttributeKeys, ValidationError } from \"@/validators/common\";\n\nexport const staticNodeValidator = (nodeData: StaticNodeData) => {\n  Object.keys(nodeData).forEach((key) => {\n    if (!staticNodeAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Static node does not allow \" + key);\n    }\n  });\n  return true;\n};\n","import { ComputedNodeData } from \"@/type\";\nimport { computedNodeAttributeKeys, ValidationError } from \"@/validators/common\";\n\nexport const computedNodeValidator = (nodeData: ComputedNodeData) => {\n  Object.keys(nodeData).forEach((key) => {\n    if (!computedNodeAttributeKeys.includes(key)) {\n      throw new ValidationError(\"Computed node does not allow \" + key);\n    }\n  });\n  return true;\n};\n","import { GraphData } from \"@/type\";\nimport { parseNodeName } from \"@/utils/utils\";\nimport { ValidationError } from \"@/validators/common\";\nimport { inputs2dataSources, dataSourceNodeIds } from \"@/utils/nodeUtils\";\n\nexport const relationValidator = (data: GraphData, staticNodeIds: string[], computedNodeIds: string[]) => {\n  const nodeIds = new Set<string>(Object.keys(data.nodes));\n\n  const pendings: Record<string, Set<string>> = {};\n  const waitlist: Record<string, Set<string>> = {};\n\n  // validate input relation and set pendings and wait list\n  computedNodeIds.forEach((computedNodeId) => {\n    const nodeData = data.nodes[computedNodeId];\n    pendings[computedNodeId] = new Set<string>();\n\n    const dataSourceValidator = (sourceType: string, sourceNodeIds: string[]) => {\n      sourceNodeIds.forEach((sourceNodeId) => {\n        if (sourceNodeId) {\n          if (!nodeIds.has(sourceNodeId)) {\n            throw new ValidationError(`${sourceType} not match: NodeId ${computedNodeId}, Inputs: ${sourceNodeId}`);\n          }\n          waitlist[sourceNodeId] === undefined && (waitlist[sourceNodeId] = new Set<string>());\n          pendings[computedNodeId].add(sourceNodeId);\n          waitlist[sourceNodeId].add(computedNodeId);\n        }\n      });\n    };\n    if (\"agent\" in nodeData && nodeData) {\n      if (nodeData.inputs) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources(nodeData.inputs));\n        dataSourceValidator(\"Inputs\", sourceNodeIds);\n      }\n      if (nodeData.if) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ if: nodeData.if }));\n        dataSourceValidator(\"If\", sourceNodeIds);\n      }\n      if (nodeData.unless) {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ unless: nodeData.unless }));\n        dataSourceValidator(\"Unless\", sourceNodeIds);\n      }\n      if (nodeData.graph && typeof nodeData?.graph === \"string\") {\n        const sourceNodeIds = dataSourceNodeIds(inputs2dataSources({ graph: nodeData.graph }));\n        dataSourceValidator(\"Graph\", sourceNodeIds);\n      }\n    }\n  });\n\n  // TODO. validate update\n  staticNodeIds.forEach((staticNodeId) => {\n    const nodeData = data.nodes[staticNodeId];\n    if (\"value\" in nodeData && nodeData.update) {\n      const update = nodeData.update;\n      const updateNodeId = parseNodeName(update).nodeId;\n      if (!updateNodeId) {\n        throw new ValidationError(\"Update it a literal\");\n      }\n      if (!nodeIds.has(updateNodeId)) {\n        throw new ValidationError(`Update not match: NodeId ${staticNodeId}, update: ${update}`);\n      }\n    }\n  });\n\n  const cycle = (possibles: string[]) => {\n    possibles.forEach((possobleNodeId) => {\n      (waitlist[possobleNodeId] || []).forEach((waitingNodeId) => {\n        pendings[waitingNodeId].delete(possobleNodeId);\n      });\n    });\n\n    const running: string[] = [];\n    Object.keys(pendings).forEach((pendingNodeId) => {\n      if (pendings[pendingNodeId].size === 0) {\n        running.push(pendingNodeId);\n        delete pendings[pendingNodeId];\n      }\n    });\n    return running;\n  };\n\n  let runningQueue = cycle(staticNodeIds);\n  if (runningQueue.length === 0) {\n    throw new ValidationError(\"No Initial Runnning Node\");\n  }\n\n  do {\n    runningQueue = cycle(runningQueue);\n  } while (runningQueue.length > 0);\n\n  if (Object.keys(pendings).length > 0) {\n    throw new ValidationError(\"Some nodes are not executed: \" + Object.keys(pendings).join(\", \"));\n  }\n};\n","import { ValidationError } from \"@/validators/common\";\n\nexport const agentValidator = (graphAgentIds: Set<string>, agentIds: Set<string>) => {\n  graphAgentIds.forEach((agentId) => {\n    if (!agentIds.has(agentId)) {\n      throw new ValidationError(\"Invalid Agent : \" + agentId + \" is not in AgentFunctionInfoDictionary.\");\n    }\n  });\n  return true;\n};\n","import { GraphData } from \"@/type\";\n\nimport { graphNodesValidator, graphDataValidator } from \"@/validators/graph_data_validator\";\nimport { nodeValidator } from \"@/validators/nodeValidator\";\nimport { staticNodeValidator } from \"@/validators/static_node_validator\";\nimport { computedNodeValidator } from \"@/validators/computed_node_validator\";\nimport { relationValidator } from \"@/validators/relation_validator\";\nimport { agentValidator } from \"@/validators/agent_validator\";\n\nexport const validateGraphData = (data: GraphData, agentIds: string[]) => {\n  graphNodesValidator(data);\n  graphDataValidator(data);\n  const computedNodeIds: string[] = [];\n  const staticNodeIds: string[] = [];\n  const graphAgentIds = new Set<string>();\n  Object.keys(data.nodes).forEach((nodeId) => {\n    const node = data.nodes[nodeId];\n    const isStaticNode = \"value\" in node;\n    nodeValidator(node);\n    const agentId = isStaticNode ? \"\" : node.agent;\n    isStaticNode && staticNodeValidator(node) && staticNodeIds.push(nodeId);\n    !isStaticNode && computedNodeValidator(node) && computedNodeIds.push(nodeId) && typeof agentId === \"string\" && graphAgentIds.add(agentId);\n  });\n  agentValidator(graphAgentIds, new Set<string>(agentIds));\n  relationValidator(data, staticNodeIds, computedNodeIds);\n\n  return true;\n};\n","import { ComputedNode } from \"@/node\";\nimport { assert } from \"@/utils/utils\";\n\ntype TaskEntry = {\n  node: ComputedNode;\n  graphId: string;\n  callback: (node: ComputedNode) => void;\n};\n\n// TaskManage object controls the concurrency of ComputedNode execution.\n//\n// NOTE: A TaskManager instance will be shared between parent graph and its children\n// when nested agents are involved.\nexport class TaskManager {\n  private concurrency: number;\n  private taskQueue: Array<TaskEntry> = [];\n  private runningNodes = new Set<ComputedNode>();\n\n  constructor(concurrency: number) {\n    this.concurrency = concurrency;\n  }\n\n  // This internal method dequeus a task from the task queue\n  // and call the associated callback method, if the number of\n  // running task is lower than the spcified limit.\n  private dequeueTaskIfPossible() {\n    if (this.runningNodes.size < this.concurrency) {\n      const task = this.taskQueue.shift();\n      if (task) {\n        this.runningNodes.add(task.node);\n        task.callback(task.node);\n      }\n    }\n  }\n\n  // Node will call this method to put itself in the execution queue.\n  // We call the associated callback function when it is dequeued.\n  public addTask(node: ComputedNode, graphId: string, callback: (node: ComputedNode) => void) {\n    // Finder tasks in the queue, which has either the same or higher priority.\n    const count = this.taskQueue.filter((task) => {\n      return task.node.priority >= node.priority;\n    }).length;\n    assert(count <= this.taskQueue.length, \"TaskManager.addTask: Something is really wrong.\");\n    this.taskQueue.splice(count, 0, { node, graphId, callback });\n    this.dequeueTaskIfPossible();\n  }\n\n  public isRunning(graphId: string) {\n    const count = [...this.runningNodes].filter((node) => {\n      return node.graphId == graphId;\n    }).length;\n    return count > 0 || Array.from(this.taskQueue).filter((data) => data.graphId === graphId).length > 0;\n  }\n\n  // Node MUST call this method once the execution of agent function is completed\n  // either successfully or not.\n  public onComplete(node: ComputedNode) {\n    assert(this.runningNodes.has(node), `TaskManager.onComplete node(${node.nodeId}) is not in list`);\n    this.runningNodes.delete(node);\n    this.dequeueTaskIfPossible();\n  }\n\n  // Node will call this method before it hands the task manager from the graph\n  // to a nested agent. We need to make it sure that there is enough room to run\n  // computed nodes inside the nested graph to avoid a deadlock.\n  public prepareForNesting() {\n    this.concurrency++;\n  }\n\n  public restoreAfterNesting() {\n    this.concurrency--;\n  }\n\n  public getStatus(verbose: boolean = false) {\n    const runningNodes = Array.from(this.runningNodes).map((node) => node.nodeId);\n    const queuedNodes = this.taskQueue.map((task) => task.node.nodeId);\n    const nodes = verbose ? { runningNodes, queuedNodes } : {};\n    return {\n      concurrency: this.concurrency,\n      queue: this.taskQueue.length,\n      running: this.runningNodes.size,\n      ...nodes,\n    };\n  }\n}\n","import {\n  AgentFunctionInfoDictionary,\n  AgentFilterInfo,\n  GraphData,\n  DataSource,\n  LoopData,\n  ResultDataDictionary,\n  ResultData,\n  DefaultResultData,\n  GraphOptions,\n  PropFunction,\n  GraphDataLoader,\n} from \"@/type\";\nimport { TransactionLog } from \"@/transaction_log\";\n\nimport { ComputedNode, StaticNode, GraphNodes } from \"@/node\";\n\nimport { resultsOf, resultOf, cleanResult } from \"@/utils/result\";\nimport { propFunctions } from \"@/utils/prop_function\";\nimport { parseNodeName, assert, isLogicallyTrue } from \"@/utils/utils\";\nimport { getDataFromSource } from \"@/utils/data_source\";\n\nimport { validateGraphData } from \"@/validator\";\nimport { TaskManager } from \"@/task_manager\";\n\nexport const defaultConcurrency = 8;\nexport const graphDataLatestVersion = 0.5;\n\nexport class GraphAI {\n  public readonly version: number;\n  private readonly graphId: string;\n  private readonly data: GraphData;\n  private readonly loop?: LoopData;\n  private readonly logs: Array<TransactionLog> = [];\n  private readonly bypassAgentIds: string[];\n  public readonly config?: Record<string, unknown> = {};\n  public readonly agentFunctionInfoDictionary: AgentFunctionInfoDictionary;\n  public readonly taskManager: TaskManager;\n  public readonly agentFilters: AgentFilterInfo[];\n  public readonly retryLimit?: number;\n  private readonly propFunctions: PropFunction[];\n  public readonly graphLoader?: GraphDataLoader;\n\n  public nodes: GraphNodes;\n  public onLogCallback = (__log: TransactionLog, __isUpdate: boolean) => {};\n  public verbose: boolean; // REVIEW: Do we need this?\n\n  private onComplete: () => void;\n  private repeatCount = 0;\n\n  // This method is called when either the GraphAI obect was created,\n  // or we are about to start n-th iteration (n>2).\n  private createNodes(data: GraphData) {\n    const nodes = Object.keys(data.nodes).reduce((_nodes: GraphNodes, nodeId: string) => {\n      const nodeData = data.nodes[nodeId];\n      if (\"value\" in nodeData) {\n        _nodes[nodeId] = new StaticNode(nodeId, nodeData, this);\n      } else if (\"agent\" in nodeData) {\n        _nodes[nodeId] = new ComputedNode(this.graphId, nodeId, nodeData, this);\n      } else {\n        throw new Error(\"Unknown node type (neither value nor agent): \" + nodeId);\n      }\n      return _nodes;\n    }, {});\n\n    // Generate the waitlist for each node.\n    Object.keys(nodes).forEach((nodeId) => {\n      const node = nodes[nodeId];\n      if (node.isComputedNode) {\n        node.pendings.forEach((pending) => {\n          if (nodes[pending]) {\n            nodes[pending].waitlist.add(nodeId); // previousNode\n          } else {\n            throw new Error(`createNode: invalid input ${pending} for node, ${nodeId}`);\n          }\n        });\n      }\n    });\n    return nodes;\n  }\n\n  private getValueFromResults(source: DataSource, results: ResultDataDictionary<DefaultResultData>) {\n    return getDataFromSource(source.nodeId ? results[source.nodeId] : undefined, source, this.propFunctions);\n  }\n\n  // for static\n  private initializeStaticNodes(enableConsoleLog: boolean = false) {\n    // If the result property is specified, inject it.\n    // If the previousResults exists (indicating we are in a loop),\n    // process the update property (nodeId or nodeId.propId).\n    Object.keys(this.data.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node?.isStaticNode) {\n        const value = node?.value;\n        if (value !== undefined) {\n          this.injectValue(nodeId, value, nodeId);\n        }\n        if (enableConsoleLog) {\n          node.consoleLog();\n        }\n      }\n    });\n  }\n\n  private updateStaticNodes(previousResults?: ResultDataDictionary<DefaultResultData>, enableConsoleLog: boolean = false) {\n    // If the result property is specified, inject it.\n    // If the previousResults exists (indicating we are in a loop),\n    // process the update property (nodeId or nodeId.propId).\n    Object.keys(this.data.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node?.isStaticNode) {\n        const update = node?.update;\n        if (update && previousResults) {\n          const result = this.getValueFromResults(update, previousResults);\n          this.injectValue(nodeId, result, update.nodeId);\n        }\n        if (enableConsoleLog) {\n          node.consoleLog();\n        }\n      }\n    });\n  }\n\n  constructor(\n    data: GraphData,\n    agentFunctionInfoDictionary: AgentFunctionInfoDictionary,\n    options: GraphOptions = {\n      taskManager: undefined,\n      agentFilters: [],\n      bypassAgentIds: [],\n      config: {},\n      graphLoader: undefined,\n    },\n  ) {\n    if (!data.version && !options.taskManager) {\n      console.warn(\"------------ missing version number\");\n    }\n    this.version = data.version ?? graphDataLatestVersion;\n    if (this.version < graphDataLatestVersion) {\n      console.warn(`------------ upgrade to ${graphDataLatestVersion}!`);\n    }\n    this.retryLimit = data.retry; // optional\n    this.graphId = URL.createObjectURL(new Blob()).slice(-36);\n    this.data = data;\n    this.agentFunctionInfoDictionary = agentFunctionInfoDictionary;\n    this.propFunctions = propFunctions;\n    this.taskManager = options.taskManager ?? new TaskManager(data.concurrency ?? defaultConcurrency);\n    this.agentFilters = options.agentFilters ?? [];\n    this.bypassAgentIds = options.bypassAgentIds ?? [];\n    this.config = options.config;\n    this.graphLoader = options.graphLoader;\n    this.loop = data.loop;\n    this.verbose = data.verbose === true;\n    this.onComplete = () => {\n      throw new Error(\"SOMETHING IS WRONG: onComplete is called without run()\");\n    };\n\n    validateGraphData(data, [...Object.keys(agentFunctionInfoDictionary), ...this.bypassAgentIds]);\n\n    this.nodes = this.createNodes(data);\n    this.initializeStaticNodes(true);\n  }\n\n  public getAgentFunctionInfo(agentId?: string) {\n    if (agentId && this.agentFunctionInfoDictionary[agentId]) {\n      return this.agentFunctionInfoDictionary[agentId];\n    }\n    if (agentId && this.bypassAgentIds.includes(agentId)) {\n      return {\n        agent: async () => {\n          return null;\n        },\n        inputs: null,\n      };\n    }\n    // We are not supposed to hit this error because the validator will catch it.\n    throw new Error(\"No agent: \" + agentId);\n  }\n\n  public asString() {\n    return Object.values(this.nodes)\n      .map((node) => node.asString())\n      .join(\"\\n\");\n  }\n\n  // Public API\n  public results<T = DefaultResultData>(all: boolean): ResultDataDictionary<T> {\n    return Object.keys(this.nodes)\n      .filter((nodeId) => all || this.nodes[nodeId].isResult)\n      .reduce((results: ResultDataDictionary<T>, nodeId) => {\n        const node = this.nodes[nodeId];\n        if (node.result !== undefined) {\n          results[nodeId] = node.result as T;\n        }\n        return results;\n      }, {});\n  }\n\n  // Public API\n  public errors(): Record<string, Error> {\n    return Object.keys(this.nodes).reduce((errors: Record<string, Error>, nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node.isComputedNode) {\n        if (node.error !== undefined) {\n          errors[nodeId] = node.error;\n        }\n      }\n      return errors;\n    }, {});\n  }\n\n  private pushReadyNodesIntoQueue() {\n    // Nodes without pending data should run immediately.\n    Object.keys(this.nodes).forEach((nodeId) => {\n      const node = this.nodes[nodeId];\n      if (node.isComputedNode) {\n        this.pushQueueIfReady(node);\n      }\n    });\n  }\n\n  private pushQueueIfReady(node: ComputedNode) {\n    if (node.isReadyNode()) {\n      this.pushQueue(node);\n    }\n  }\n\n  public pushQueueIfReadyAndRunning(node: ComputedNode) {\n    if (this.isRunning()) {\n      this.pushQueueIfReady(node);\n    }\n  }\n\n  // for computed\n  public pushQueue(node: ComputedNode) {\n    node.beforeAddTask();\n\n    this.taskManager.addTask(node, this.graphId, (_node) => {\n      assert(node.nodeId === _node.nodeId, \"GraphAI.pushQueue node mismatch\");\n      node.execute();\n    });\n  }\n\n  // Public API\n  public async run<T = DefaultResultData>(all: boolean = false): Promise<ResultDataDictionary<T>> {\n    if (this.isRunning()) {\n      throw new Error(\"This GraphUI instance is already running\");\n    }\n\n    this.pushReadyNodesIntoQueue();\n\n    if (!this.isRunning()) {\n      console.warn(\"-- nothing to execute\");\n      return {};\n    }\n\n    return new Promise((resolve, reject) => {\n      this.onComplete = () => {\n        const errors = this.errors();\n        const nodeIds = Object.keys(errors);\n        if (nodeIds.length > 0) {\n          reject(errors[nodeIds[0]]);\n        } else {\n          resolve(this.results(all));\n        }\n      };\n    });\n  }\n\n  // Public only for testing\n  public isRunning() {\n    return this.taskManager.isRunning(this.graphId);\n  }\n\n  // callback from execute\n  public onExecutionComplete(node: ComputedNode) {\n    this.taskManager.onComplete(node);\n    if (this.isRunning() || this.processLoopIfNecessary()) {\n      return; // continue running\n    }\n    this.onComplete(); // Nothing to run. Finish it.\n  }\n\n  // Must be called only from onExecutionComplete righ after removeRunning\n  // Check if there is any running computed nodes.\n  // In case of no running computed note, start the another iteration if ncessary (loop)\n  private processLoopIfNecessary() {\n    this.repeatCount++;\n    const loop = this.loop;\n    if (!loop) {\n      return false;\n    }\n\n    // We need to update static nodes, before checking the condition\n    const previousResults = this.results(true); // results from previous loop\n    this.updateStaticNodes(previousResults);\n\n    if (loop.count === undefined || this.repeatCount < loop.count) {\n      if (loop.while) {\n        const source = parseNodeName(loop.while);\n        const value = this.getValueFromResults(source, this.results(true));\n        // NOTE: We treat an empty array as false.\n        if (!isLogicallyTrue(value)) {\n          return false; // while condition is not met\n        }\n      }\n      this.nodes = this.createNodes(this.data);\n      this.initializeStaticNodes();\n      this.updateStaticNodes(previousResults, true);\n\n      this.pushReadyNodesIntoQueue();\n      return true; // Indicating that we are going to continue.\n    }\n    return false;\n  }\n\n  public setLoopLog(log: TransactionLog) {\n    log.isLoop = !!this.loop;\n    log.repeatCount = this.repeatCount;\n  }\n\n  public appendLog(log: TransactionLog) {\n    this.logs.push(log);\n    this.onLogCallback(log, false);\n  }\n\n  public updateLog(log: TransactionLog) {\n    this.onLogCallback(log, true);\n  }\n\n  // Public API\n  public transactionLogs() {\n    return this.logs;\n  }\n\n  // Public API\n  public injectValue(nodeId: string, value: ResultData, injectFrom?: string): void {\n    const node = this.nodes[nodeId];\n    if (node && node.isStaticNode) {\n      node.injectValue(value, injectFrom);\n    } else {\n      throw new Error(`injectValue with Invalid nodeId, ${nodeId}`);\n    }\n  }\n\n  public resultsOf(inputs?: Array<any> | Record<string, any>, anyInput: boolean = false) {\n    const results = resultsOf(inputs ?? [], this.nodes, this.propFunctions);\n    if (anyInput) {\n      return cleanResult(results);\n    }\n    return results;\n  }\n  public resultOf(source: DataSource) {\n    return resultOf(source, this.nodes, this.propFunctions);\n  }\n}\n"],"names":["NodeState"],"mappings":"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"}